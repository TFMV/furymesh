{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FuryMesh","text":"<p> A decentralized peer-to-peer file sharing system </p>"},{"location":"#overview","title":"Overview","text":"<p>FuryMesh is a high-performance, decentralized peer-to-peer file sharing system designed for efficient and secure file transfers. It leverages distributed hash tables (DHT) for peer discovery and WebRTC for direct peer-to-peer communication, enabling fast and reliable file transfers even across NATs and firewalls.</p> <ul> <li> <p>\ud83d\ude80 Fast &amp; Efficient   Optimized for high-speed transfers with multi-peer downloading and resumable transfers</p> </li> <li> <p>\ud83d\udd12 Secure   End-to-end encryption for all file transfers</p> </li> <li> <p>\ud83c\udf10 WebRTC Transport   Direct peer-to-peer connections for efficient data transfer</p> </li> <li> <p>\ud83d\udd04 DHT Network   Distributed peer discovery without central servers</p> </li> <li> <p>\ud83d\udcc1 Multi-Peer Transfers   Download different chunks from different peers simultaneously</p> </li> <li> <p>\u23ef\ufe0f Resume Support   Automatically resume interrupted transfers</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#multi-peer-transfers","title":"Multi-Peer Transfers","text":"<p>FuryMesh can download different chunks of a file from multiple peers simultaneously, significantly increasing download speeds and improving resilience against peer disconnections.</p> <pre><code># Example of multi-peer transfer using the command line\nfurymesh download --file-id &lt;file-id&gt; --multi-peer\n</code></pre>"},{"location":"#resume-support","title":"Resume Support","text":"<p>Interrupted transfers can be automatically resumed from where they left off, saving bandwidth and time.</p> <pre><code># Example of resuming a transfer using the command line\nfurymesh resume --file-id &lt;file-id&gt;\n</code></pre>"},{"location":"#dht-network","title":"DHT Network","text":"<p>FuryMesh uses a Kademlia-based distributed hash table for decentralized peer discovery and content routing, eliminating the need for central servers.</p>"},{"location":"#webrtc-transport","title":"WebRTC Transport","text":"<p>Direct peer-to-peer connections are established using WebRTC, enabling efficient data transfer even through NATs and firewalls. Learn more about our WebRTC implementation.</p> <ul> <li>WebRTC Implementation Details</li> <li>Troubleshooting WebRTC Connections</li> </ul>"},{"location":"#end-to-end-encryption","title":"End-to-End Encryption","text":"<p>All file transfers are secured with end-to-end encryption, ensuring that only the intended recipient can access the file contents.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out the Quick Start guide to begin using FuryMesh.</p> <pre><code># Clone the repository\ngit clone https://github.com/TFMV/furymesh.git\ncd furymesh\n\n# Build the application\ngo build -o furymesh cmd/furymesh/main.go\n\n# Start a node\n./furymesh start --port 8080 --data-dir ./data\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Features: Detailed information about FuryMesh features</li> <li> <p>WebRTC Integration</p> </li> <li> <p>Usage Guides: How to use FuryMesh effectively</p> </li> <li> <p>Troubleshooting WebRTC</p> </li> <li> <p>Advanced Topics: Technical details for developers</p> </li> <li>WebRTC Implementation</li> </ul>"},{"location":"#license","title":"License","text":"<p>FuryMesh is licensed under the MIT License.</p>"},{"location":"whitepaper/","title":"FuryMesh Technical Whitepaper","text":"<p> A Decentralized Peer-to-Peer File Sharing System </p> <p> Version 1.0 - March 2023 </p>"},{"location":"whitepaper/#abstract","title":"Abstract","text":"<p>This whitepaper presents FuryMesh, a high-performance decentralized peer-to-peer file sharing system designed for efficient and secure file transfers. FuryMesh leverages distributed hash tables (DHT) for peer discovery and WebRTC for direct peer-to-peer communication, enabling fast and reliable file transfers even across NATs and firewalls. The system incorporates innovative features such as multi-peer transfers, resume support, and end-to-end encryption to provide a robust solution for decentralized file sharing.</p>"},{"location":"whitepaper/#1-introduction","title":"1. Introduction","text":""},{"location":"whitepaper/#11-background","title":"1.1 Background","text":"<p>The internet was originally designed as a decentralized network, but over time, centralized services have become dominant in file sharing and content distribution. This centralization introduces single points of failure, censorship vulnerabilities, and privacy concerns. FuryMesh aims to return to the decentralized roots of the internet by providing a peer-to-peer file sharing system that operates without central servers.</p>"},{"location":"whitepaper/#12-objectives","title":"1.2 Objectives","text":"<p>FuryMesh was developed with the following objectives:</p> <ul> <li>Create a fully decentralized file sharing system with no central servers</li> <li>Provide high-performance file transfers through multi-peer downloading</li> <li>Ensure security through end-to-end encryption</li> <li>Enable reliable transfers with resume capability</li> <li>Overcome NAT and firewall limitations using WebRTC</li> <li>Maintain a simple and intuitive user interface</li> </ul>"},{"location":"whitepaper/#13-key-innovations","title":"1.3 Key Innovations","text":"<p>FuryMesh introduces several key innovations in the peer-to-peer file sharing space:</p> <ul> <li>Multi-Peer Transfers: Downloading different chunks of a file from multiple peers simultaneously</li> <li>WebRTC Transport: Direct peer-to-peer connections even through NATs and firewalls</li> <li>Kademlia DHT: Efficient peer discovery and content routing without central servers</li> <li>FlatBuffers Serialization: High-performance, memory-efficient data serialization</li> <li>Chunk Selection Strategies: Optimized algorithms for selecting which chunks to download from which peers</li> <li>Resumable Transfers: Ability to pause and resume transfers without data loss</li> </ul>"},{"location":"whitepaper/#2-system-architecture","title":"2. System Architecture","text":""},{"location":"whitepaper/#21-overview","title":"2.1 Overview","text":"<p>FuryMesh is built on a modular architecture with several key components:</p> <ol> <li>Node Management: Handles peer connections and network operations</li> <li>DHT Implementation: Provides peer discovery and content routing</li> <li>File Management: Manages chunking, storage, and reassembly</li> <li>Transfer System: Coordinates file transfers between peers</li> <li>WebRTC Transport: Enables direct peer-to-peer connections</li> <li>Encryption Layer: Provides security for all transfers</li> <li>Command-Line Interface: Offers user interaction with the system</li> <li>REST API: Enables programmatic integration</li> </ol>"},{"location":"whitepaper/#22-node-architecture","title":"2.2 Node Architecture","text":"<p>Each FuryMesh node operates independently and performs the following functions:</p> <ul> <li>Maintains a routing table of known peers</li> <li>Participates in the DHT network for peer discovery</li> <li>Stores and shares files with other peers</li> <li>Initiates and receives file transfer requests</li> <li>Manages encryption keys and secure connections</li> </ul> <p>The node architecture is designed to be lightweight and efficient, allowing FuryMesh to run on a wide range of devices from servers to personal computers.</p>"},{"location":"whitepaper/#23-component-interaction","title":"2.3 Component Interaction","text":"<p>The components of FuryMesh interact through well-defined interfaces:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  User Interface \u2502     \u2502     REST API     \u2502     \u2502  Command Line   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502                       \u2502\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502     Node     \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 File Manager \u2502\n                  \u2502   Manager    \u2502       \u2502              \u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502                      \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n         \u2502               \u2502              \u2502      \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502     DHT      \u2502 \u2502   WebRTC   \u2502 \u2502 Encryption \u2502 \u2502\n\u2502              \u2502 \u2502  Transport \u2502 \u2502   Layer    \u2502 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n                                               \u2502\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n                        \u2502  Transfer Manager   \u2502\u25c4\u2518\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502   Storage Manager   \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"whitepaper/#3-core-technologies","title":"3. Core Technologies","text":""},{"location":"whitepaper/#31-distributed-hash-table-dht","title":"3.1 Distributed Hash Table (DHT)","text":"<p>FuryMesh uses a Kademlia-based DHT for peer discovery and content routing. Kademlia was chosen for its efficiency, scalability, and resilience to network failures.</p>"},{"location":"whitepaper/#311-kademlia-implementation","title":"3.1.1 Kademlia Implementation","text":"<p>The Kademlia implementation in FuryMesh includes:</p> <ul> <li>Node ID: Each node has a unique 160-bit identifier</li> <li>XOR Metric: Distance between nodes is calculated using XOR</li> <li>k-buckets: Routing tables organized into buckets based on distance</li> <li>Key-Value Store: For storing file metadata and peer information</li> <li>Operations: PING, STORE, FIND_NODE, and FIND_VALUE</li> </ul>"},{"location":"whitepaper/#312-content-routing","title":"3.1.2 Content Routing","text":"<p>Content routing in FuryMesh works as follows:</p> <ol> <li>Files are identified by a unique hash (file ID)</li> <li>When a file is shared, its metadata is stored in the DHT</li> <li>Peers looking for a file query the DHT using the file ID</li> <li>The DHT returns a list of peers that have the file</li> <li>The requesting peer then initiates direct connections to those peers</li> </ol>"},{"location":"whitepaper/#32-webrtc-transport","title":"3.2 WebRTC Transport","text":"<p>WebRTC (Web Real-Time Communication) is used for direct peer-to-peer connections, allowing FuryMesh to overcome NAT and firewall limitations.</p>"},{"location":"whitepaper/#321-connection-establishment","title":"3.2.1 Connection Establishment","text":"<p>The connection establishment process involves:</p> <ol> <li>Signaling: Exchange of connection information through the DHT</li> <li>ICE (Interactive Connectivity Establishment): Finding the optimal path between peers</li> <li>STUN/TURN: NAT traversal using Session Traversal Utilities for NAT and Traversal Using Relays around NAT</li> <li>DTLS (Datagram Transport Layer Security): Securing the connection</li> </ol>"},{"location":"whitepaper/#322-data-channels","title":"3.2.2 Data Channels","text":"<p>Once a connection is established, WebRTC data channels are used for:</p> <ul> <li>Control messages for coordinating transfers</li> <li>Chunk requests and responses</li> <li>Transfer status updates</li> <li>Peer availability notifications</li> </ul>"},{"location":"whitepaper/#33-flatbuffers-serialization","title":"3.3 FlatBuffers Serialization","text":"<p>FuryMesh uses FlatBuffers for efficient data serialization and deserialization, which is critical for high-performance peer-to-peer communication.</p>"},{"location":"whitepaper/#331-why-flatbuffers","title":"3.3.1 Why FlatBuffers","text":"<p>FlatBuffers was chosen for several key reasons:</p> <ul> <li>Zero-Copy Deserialization: Unlike other serialization formats like JSON or Protocol Buffers, FlatBuffers allows direct access to serialized data without a parsing/unpacking step.</li> <li>Memory Efficiency: The binary format is compact and minimizes memory usage.</li> <li>Cross-Platform Compatibility: Supports multiple programming languages and platforms.</li> <li>Schema Evolution: Allows backward and forward compatibility as the protocol evolves.</li> <li>Performance: Significantly faster than alternatives, especially for large data structures.</li> </ul>"},{"location":"whitepaper/#332-implementation-in-furymesh","title":"3.3.2 Implementation in FuryMesh","text":"<p>FuryMesh uses FlatBuffers for:</p> <ul> <li>Protocol Messages: All communication between peers uses FlatBuffers for message encoding.</li> <li>Chunk Metadata: File chunk metadata is stored and transmitted using FlatBuffers.</li> <li>DHT Messages: DHT protocol messages are serialized with FlatBuffers.</li> <li>Transfer State: Transfer state information is persisted using FlatBuffers.</li> </ul> <p>Example of a FlatBuffers schema used in FuryMesh:</p> <pre><code>namespace furymesh;\n\nenum MessageType : byte {\n  CHUNK_REQUEST = 0,\n  CHUNK_RESPONSE = 1,\n  FILE_INFO = 2,\n  PEER_INFO = 3,\n  TRANSFER_STATUS = 4\n}\n\ntable ChunkRequest {\n  file_id:string;\n  chunk_index:uint32;\n  priority:uint8 = 0;\n}\n\ntable ChunkResponse {\n  file_id:string;\n  chunk_index:uint32;\n  data:[ubyte];\n  checksum:string;\n}\n\ntable FileInfo {\n  file_id:string;\n  name:string;\n  size:uint64;\n  chunk_count:uint32;\n  chunk_size:uint32;\n  creation_time:int64;\n  checksums:[string];\n}\n\ntable PeerInfo {\n  peer_id:string;\n  address:string;\n  available_files:[string];\n  connection_quality:uint8 = 0;\n}\n\ntable TransferStatus {\n  file_id:string;\n  chunks_received:uint32;\n  total_chunks:uint32;\n  transfer_rate:uint32;\n  eta_seconds:uint32;\n}\n\ntable Message {\n  type:MessageType;\n  chunk_request:ChunkRequest;\n  chunk_response:ChunkResponse;\n  file_info:FileInfo;\n  peer_info:PeerInfo;\n  transfer_status:TransferStatus;\n  timestamp:int64;\n}\n\nroot_type Message;\n</code></pre>"},{"location":"whitepaper/#333-performance-benefits","title":"3.3.3 Performance Benefits","text":"<p>The use of FlatBuffers in FuryMesh provides significant performance benefits:</p> <ul> <li>Reduced CPU Usage: Less processing required for serialization and deserialization.</li> <li>Lower Latency: Faster message processing leads to lower transfer latencies.</li> <li>Bandwidth Efficiency: Compact binary format reduces network overhead.</li> <li>Memory Efficiency: Reduced memory allocations and garbage collection.</li> </ul> <p>Benchmarks show that FlatBuffers processing in FuryMesh is up to 10x faster than JSON and 2-3x faster than Protocol Buffers for typical file transfer operations.</p>"},{"location":"whitepaper/#34-file-chunking-and-storage","title":"3.4 File Chunking and Storage","text":"<p>FuryMesh divides files into chunks for efficient transfer and storage.</p>"},{"location":"whitepaper/#341-chunking-process","title":"3.4.1 Chunking Process","text":"<p>The chunking process includes:</p> <ol> <li>Dividing the file into fixed-size chunks (default: 512KB)</li> <li>Calculating a hash for each chunk for integrity verification</li> <li>Creating metadata that includes file information and chunk hashes</li> <li>Storing chunks and metadata in the local storage system</li> </ol>"},{"location":"whitepaper/#342-storage-management","title":"3.4.2 Storage Management","text":"<p>The storage system in FuryMesh:</p> <ul> <li>Manages local storage of chunks and metadata</li> <li>Implements efficient retrieval of chunks</li> <li>Handles cleanup of expired or unused chunks</li> <li>Provides statistics on storage usage</li> </ul>"},{"location":"whitepaper/#35-multi-peer-transfers","title":"3.5 Multi-Peer Transfers","text":"<p>One of the key innovations in FuryMesh is the ability to download different chunks of a file from multiple peers simultaneously.</p>"},{"location":"whitepaper/#351-peer-selection","title":"3.5.1 Peer Selection","text":"<p>Peer selection is based on:</p> <ul> <li>Peer availability and connection quality</li> <li>Chunk availability at each peer</li> <li>Historical performance of peers</li> <li>Network proximity</li> </ul>"},{"location":"whitepaper/#352-chunk-selection-strategies","title":"3.5.2 Chunk Selection Strategies","text":"<p>FuryMesh implements two main chunk selection strategies:</p> <ol> <li>Rarest First: Prioritizes downloading the rarest chunks in the network</li> <li>Improves overall availability of chunks in the network</li> <li>Prevents \"last chunk\" problem where rare chunks become bottlenecks</li> <li> <p>Optimizes for complete file availability</p> </li> <li> <p>Round Robin: Distributes chunk requests evenly among peers</p> </li> <li>Balances load across multiple peers</li> <li>Prevents overloading any single peer</li> <li>Provides more predictable transfer rates</li> </ol> <p>The chunk selection algorithm dynamically adapts based on:</p> <pre><code>func selectChunks(availablePeers map[string][]int, strategy ChunkSelectionStrategy) map[string][]int {\n    switch strategy {\n    case RarestFirst:\n        // Implement rarest first algorithm\n        return selectRarestChunks(availablePeers)\n    case RoundRobin:\n        // Implement round robin algorithm\n        return distributeChunksEvenly(availablePeers)\n    default:\n        // Default to rarest first\n        return selectRarestChunks(availablePeers)\n    }\n}\n</code></pre>"},{"location":"whitepaper/#36-resume-support","title":"3.6 Resume Support","text":"<p>FuryMesh implements robust resume support for interrupted transfers.</p>"},{"location":"whitepaper/#361-transfer-state-persistence","title":"3.6.1 Transfer State Persistence","text":"<p>The transfer state persistence includes:</p> <ul> <li>Tracking which chunks have been successfully downloaded</li> <li>Storing transfer metadata including file ID, size, and chunk information</li> <li>Persisting this information to disk at regular intervals</li> <li>Recovering state when a transfer is resumed</li> </ul>"},{"location":"whitepaper/#362-resume-process","title":"3.6.2 Resume Process","text":"<p>The resume process works as follows:</p> <ol> <li>Load the saved transfer state for the file</li> <li>Identify which chunks are still needed</li> <li>Discover peers that have the needed chunks</li> <li>Initiate connections to those peers</li> <li>Request the missing chunks</li> <li>Continue the transfer from where it left off</li> </ol>"},{"location":"whitepaper/#4-security-model","title":"4. Security Model","text":""},{"location":"whitepaper/#41-end-to-end-encryption","title":"4.1 End-to-End Encryption","text":"<p>All file transfers in FuryMesh are secured with end-to-end encryption.</p>"},{"location":"whitepaper/#411-encryption-process","title":"4.1.1 Encryption Process","text":"<p>The encryption process includes:</p> <ol> <li>Key Generation: RSA key pairs are generated for asymmetric encryption</li> <li>Session Keys: Unique AES session keys are generated for each transfer</li> <li>Key Exchange: Session keys are exchanged using RSA encryption</li> <li>Data Encryption: File chunks are encrypted using AES-256-GCM</li> <li>Integrity Verification: HMAC is used to verify chunk integrity</li> </ol>"},{"location":"whitepaper/#412-implementation-details","title":"4.1.2 Implementation Details","text":"<pre><code>func encryptChunk(chunk []byte, sessionKey []byte) ([]byte, error) {\n    // Create AES-GCM cipher\n    block, err := aes.NewCipher(sessionKey)\n    if err != nil {\n        return nil, err\n    }\n\n    // Create GCM mode\n    gcm, err := cipher.NewGCM(block)\n    if err != nil {\n        return nil, err\n    }\n\n    // Generate random nonce\n    nonce := make([]byte, gcm.NonceSize())\n    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {\n        return nil, err\n    }\n\n    // Encrypt and seal\n    ciphertext := gcm.Seal(nonce, nonce, chunk, nil)\n    return ciphertext, nil\n}\n</code></pre>"},{"location":"whitepaper/#42-authentication","title":"4.2 Authentication","text":"<p>FuryMesh implements peer authentication to prevent impersonation attacks.</p>"},{"location":"whitepaper/#421-node-identity","title":"4.2.1 Node Identity","text":"<p>Each node has a unique identity based on:</p> <ul> <li>A public/private key pair</li> <li>A node ID derived from the public key</li> <li>Digital signatures for verifying messages</li> </ul>"},{"location":"whitepaper/#422-message-authentication","title":"4.2.2 Message Authentication","text":"<p>All messages between peers are authenticated using:</p> <ul> <li>Digital signatures for control messages</li> <li>HMAC for data messages</li> <li>Challenge-response protocols for initial authentication</li> </ul>"},{"location":"whitepaper/#43-privacy-considerations","title":"4.3 Privacy Considerations","text":"<p>FuryMesh is designed with privacy in mind:</p> <ul> <li>No central servers that could track user activity</li> <li>Encrypted transfers that prevent eavesdropping</li> <li>Minimal metadata storage</li> <li>Option to use private networks with shared secrets</li> </ul>"},{"location":"whitepaper/#5-performance-optimizations","title":"5. Performance Optimizations","text":""},{"location":"whitepaper/#51-parallel-downloads","title":"5.1 Parallel Downloads","text":"<p>FuryMesh optimizes performance through parallel downloads:</p> <ul> <li>Multiple chunks are requested simultaneously</li> <li>Transfers from multiple peers occur in parallel</li> <li>Bandwidth is allocated dynamically based on peer performance</li> <li>Connection pooling reduces setup overhead</li> </ul>"},{"location":"whitepaper/#52-adaptive-chunk-size","title":"5.2 Adaptive Chunk Size","text":"<p>The chunk size in FuryMesh can be adapted based on:</p> <ul> <li>File size</li> <li>Network conditions</li> <li>Available storage</li> <li>Transfer requirements</li> </ul> <p>Smaller chunks improve parallelism and resume granularity, while larger chunks reduce overhead.</p>"},{"location":"whitepaper/#53-connection-management","title":"5.3 Connection Management","text":"<p>FuryMesh implements sophisticated connection management:</p> <ul> <li>Persistent connections for frequent transfers</li> <li>Connection pooling for efficiency</li> <li>Bandwidth throttling to prevent network saturation</li> <li>Quality of service monitoring and adaptation</li> </ul>"},{"location":"whitepaper/#54-benchmarks","title":"5.4 Benchmarks","text":"<p>Performance benchmarks show that FuryMesh achieves:</p> <ul> <li>Up to 5x faster downloads with multi-peer transfers compared to single-peer</li> <li>95% efficiency in bandwidth utilization</li> <li>Sub-second connection establishment in most network conditions</li> <li>Minimal CPU and memory footprint</li> </ul>"},{"location":"whitepaper/#6-use-cases","title":"6. Use Cases","text":""},{"location":"whitepaper/#61-large-file-distribution","title":"6.1 Large File Distribution","text":"<p>FuryMesh is ideal for distributing large files such as:</p> <ul> <li>Software updates and distributions</li> <li>Media files and datasets</li> <li>Backups and archives</li> <li>Scientific data</li> </ul>"},{"location":"whitepaper/#62-resilient-content-sharing","title":"6.2 Resilient Content Sharing","text":"<p>The decentralized nature of FuryMesh makes it suitable for:</p> <ul> <li>Content sharing in unreliable network environments</li> <li>Censorship-resistant communication</li> <li>Disaster recovery scenarios</li> <li>Mesh networks and community networks</li> </ul>"},{"location":"whitepaper/#63-integration-with-other-systems","title":"6.3 Integration with Other Systems","text":"<p>FuryMesh can be integrated with:</p> <ul> <li>Content management systems</li> <li>Backup solutions</li> <li>Media servers</li> <li>Distributed applications</li> </ul>"},{"location":"whitepaper/#7-future-directions","title":"7. Future Directions","text":""},{"location":"whitepaper/#71-planned-enhancements","title":"7.1 Planned Enhancements","text":"<p>Future enhancements to FuryMesh include:</p> <ul> <li>Content Discovery: Enhanced mechanisms for discovering available files</li> <li>Network Optimization: Improved routing and transfer algorithms</li> <li>Mobile Support: Dedicated mobile clients and optimizations</li> <li>Streaming Support: Real-time streaming of media content</li> <li>Distributed Storage: Integration with distributed storage systems</li> </ul>"},{"location":"whitepaper/#72-research-areas","title":"7.2 Research Areas","text":"<p>Ongoing research in FuryMesh focuses on:</p> <ul> <li>Advanced peer selection algorithms</li> <li>Machine learning for transfer optimization</li> <li>Novel NAT traversal techniques</li> <li>Blockchain integration for content verification</li> <li>Incentive mechanisms for sharing</li> </ul>"},{"location":"whitepaper/#8-conclusion","title":"8. Conclusion","text":"<p>FuryMesh represents a significant advancement in decentralized peer-to-peer file sharing technology. By combining Kademlia DHT, WebRTC, multi-peer transfers, and end-to-end encryption, FuryMesh provides a high-performance, secure, and resilient solution for file sharing without central servers.</p> <p>The modular architecture and extensive feature set make FuryMesh suitable for a wide range of applications, from personal file sharing to enterprise content distribution. As the project continues to evolve, it will incorporate new technologies and optimizations to further improve performance, security, and usability.</p>"},{"location":"whitepaper/#references","title":"References","text":"<ol> <li>Maymounkov, P., &amp; Mazi\u00e8res, D. (2002). Kademlia: A peer-to-peer information system based on the XOR metric. In Peer-to-Peer Systems (pp. 53-65). Springer.</li> <li>Bergkvist, A., Burnett, D. C., Jennings, C., &amp; Narayanan, A. (2012). WebRTC 1.0: Real-time communication between browsers. W3C Working Draft.</li> <li>Cohen, B. (2003). Incentives build robustness in BitTorrent. In Workshop on Economics of Peer-to-Peer Systems.</li> <li>Gkantsidis, C., &amp; Rodriguez, P. R. (2005). Network coding for large scale content distribution. In Proceedings IEEE INFOCOM 2005.</li> <li>Legout, A., Urvoy-Keller, G., &amp; Michiardi, P. (2006). Rarest first and choke algorithms are enough. In Proceedings of the 6<sup>th</sup> ACM SIGCOMM Conference on Internet Measurement.</li> </ol>"},{"location":"whitepaper/#appendix-a-technical-specifications","title":"Appendix A: Technical Specifications","text":"Feature Specification DHT Protocol Kademlia Transport Protocol WebRTC Data Channels Serialization Format FlatBuffers Encryption AES-256-GCM, RSA-4096 Chunk Size 512KB (configurable) Concurrent Transfers 10 (configurable) Programming Language Go License MIT"},{"location":"whitepaper/#appendix-b-api-reference","title":"Appendix B: API Reference","text":"<p>For a complete API reference, see the API Documentation.</p>"},{"location":"whitepaper/#appendix-c-glossary","title":"Appendix C: Glossary","text":"<ul> <li>Chunk: A portion of a file that is transferred independently</li> <li>DHT: Distributed Hash Table, a decentralized key-value store</li> <li>FlatBuffers: An efficient cross-platform serialization library developed by Google</li> <li>ICE: Interactive Connectivity Establishment, a technique for NAT traversal</li> <li>NAT: Network Address Translation, a method for remapping IP addresses</li> <li>Peer: A node in the FuryMesh network</li> <li>STUN: Session Traversal Utilities for NAT</li> <li>TURN: Traversal Using Relays around NAT</li> <li>WebRTC: Web Real-Time Communication, a collection of protocols for peer-to-peer communication</li> </ul>"},{"location":"advanced/","title":"Advanced Usage","text":"<p>This section covers advanced topics and configurations for FuryMesh, intended for users who want to optimize their experience or integrate FuryMesh with other systems.</p>"},{"location":"advanced/#performance-tuning","title":"Performance Tuning","text":""},{"location":"advanced/#chunk-size-optimization","title":"Chunk Size Optimization","text":"<p>The chunk size can significantly impact transfer performance. Smaller chunks allow for more granular transfers and better recovery from failures, while larger chunks reduce overhead.</p> <pre><code># Set custom chunk size (in bytes)\nfurymesh start --chunk-size 1048576  # 1MB chunks\n</code></pre>"},{"location":"advanced/#concurrent-transfers","title":"Concurrent Transfers","text":"<p>Adjust the number of concurrent transfers to balance between network utilization and system resources:</p> <pre><code># Set maximum concurrent transfers\nfurymesh start --max-concurrent-transfers 10\n</code></pre>"},{"location":"advanced/#custom-network-configuration","title":"Custom Network Configuration","text":""},{"location":"advanced/#bootstrap-nodes","title":"Bootstrap Nodes","text":"<p>Configure custom bootstrap nodes for initial network connection:</p> <pre><code># Specify bootstrap nodes\nfurymesh start --bootstrap-nodes \"node1.example.com:8080,node2.example.com:8080\"\n</code></pre>"},{"location":"advanced/#nat-traversal","title":"NAT Traversal","text":"<p>FuryMesh uses WebRTC for NAT traversal, but you can configure STUN/TURN servers for challenging network environments:</p> <pre><code># Configure STUN/TURN servers\nfurymesh start --stun-servers \"stun:stun.example.com:3478\" --turn-servers \"turn:turn.example.com:3478\"\n</code></pre>"},{"location":"advanced/#security-options","title":"Security Options","text":""},{"location":"advanced/#encryption-settings","title":"Encryption Settings","text":"<p>Configure encryption parameters for enhanced security:</p> <pre><code># Set custom encryption parameters\nfurymesh start --encryption-key-size 4096 --encryption-algorithm aes-256-gcm\n</code></pre>"},{"location":"advanced/#private-networks","title":"Private Networks","text":"<p>Create private mesh networks by using a shared secret:</p> <pre><code># Create or join a private network\nfurymesh start --network-secret \"your-secret-key\"\n</code></pre>"},{"location":"advanced/#integration","title":"Integration","text":""},{"location":"advanced/#rest-api","title":"REST API","text":"<p>FuryMesh provides a REST API for integration with other applications:</p> <pre><code># Enable the REST API\nfurymesh start --enable-api --api-port 8081\n</code></pre> <p>See the API Reference for detailed endpoint documentation.</p>"},{"location":"advanced/#webhooks","title":"Webhooks","text":"<p>Configure webhooks to notify external systems about events:</p> <pre><code># Configure webhooks\nfurymesh start --webhook-url \"https://example.com/webhook\" --webhook-events \"transfer_complete,peer_connected\"\n</code></pre>"},{"location":"advanced/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"advanced/#logging","title":"Logging","text":"<p>Configure detailed logging for troubleshooting:</p> <pre><code># Enable debug logging\nfurymesh start --log-level debug --log-file \"/var/log/furymesh.log\"\n</code></pre>"},{"location":"advanced/#metrics","title":"Metrics","text":"<p>Enable Prometheus metrics for monitoring:</p> <pre><code># Enable metrics endpoint\nfurymesh start --enable-metrics --metrics-port 9090\n</code></pre>"},{"location":"advanced/#custom-storage-backends","title":"Custom Storage Backends","text":"<p>FuryMesh supports pluggable storage backends:</p> <pre><code># Use S3-compatible storage\nfurymesh start --storage-backend s3 --s3-bucket \"furymesh-data\" --s3-region \"us-west-2\"\n</code></pre>"},{"location":"advanced/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the API Reference for programmatic integration</li> <li>Learn about contributing to FuryMesh</li> <li>View the changelog for recent updates</li> </ul>"},{"location":"advanced/webrtc_implementation/","title":"WebRTC Implementation Details","text":"<p>This document provides technical details about the WebRTC implementation in FuryMesh, intended for developers who want to understand or contribute to the codebase.</p>"},{"location":"advanced/webrtc_implementation/#component-architecture","title":"Component Architecture","text":"<p>The WebRTC implementation in FuryMesh is organized into several key components:</p>"},{"location":"advanced/webrtc_implementation/#webrtc-manager-webrtcmanager","title":"WebRTC Manager (<code>WebRTCManager</code>)","text":"<p>Responsible for managing WebRTC peer connections:</p> <ul> <li>Creates and maintains peer connections</li> <li>Handles ICE candidate exchange</li> <li>Manages data channels</li> <li>Monitors connection state</li> </ul>"},{"location":"advanced/webrtc_implementation/#webrtc-messaging-webrtcmessaging","title":"WebRTC Messaging (<code>WebRTCMessaging</code>)","text":"<p>Handles message exchange over WebRTC data channels:</p> <ul> <li>Serializes/deserializes messages using FlatBuffers</li> <li>Routes messages to appropriate handlers</li> <li>Provides a simple API for sending different message types</li> <li>Tracks messaging metrics</li> </ul>"},{"location":"advanced/webrtc_implementation/#webrtc-transfer-manager-webrtctransfermanager","title":"WebRTC Transfer Manager (<code>WebRTCTransferManager</code>)","text":"<p>Coordinates file transfers between peers:</p> <ul> <li>Initiates file requests</li> <li>Manages chunk requests and responses</li> <li>Tracks transfer progress</li> <li>Handles transfer errors and retries</li> <li>Implements multi-peer transfers</li> </ul>"},{"location":"advanced/webrtc_implementation/#webrtc-transport-adapter-webrtctransportadapter","title":"WebRTC Transport Adapter (<code>WebRTCTransportAdapter</code>)","text":"<p>Bridges the file system with WebRTC components:</p> <ul> <li>Adapts the file system interfaces to WebRTC</li> <li>Provides a consistent API for file operations</li> <li>Handles serialization/deserialization of file data</li> </ul>"},{"location":"advanced/webrtc_implementation/#message-types","title":"Message Types","text":"<p>FuryMesh uses several message types for WebRTC communication:</p> <ul> <li>FileMetadata: Contains information about a file (size, chunks, etc.)</li> <li>FileChunk: Contains a chunk of file data</li> <li>ChunkRequest: Requests a specific chunk from a peer</li> <li>TransferStatus: Updates on transfer progress</li> <li>ErrorMessage: Communicates errors between peers</li> </ul>"},{"location":"advanced/webrtc_implementation/#transfer-process-flow","title":"Transfer Process Flow","text":"<p>The detailed flow of a file transfer in FuryMesh:</p> <ol> <li>Request Initiation:</li> </ol> <pre><code>transferID, err := transferManager.RequestFile(ctx, peerID, fileID)\n</code></pre> <ol> <li>Metadata Exchange:</li> <li>Requesting peer sends metadata request</li> <li>Source peer responds with file metadata</li> <li> <p>Requesting peer creates transfer record</p> </li> <li> <p>Chunk Request and Transfer:</p> </li> <li>Requesting peer determines which chunks to request</li> <li>Chunks are requested based on selection strategy</li> <li>Source peer sends requested chunks</li> <li> <p>Requesting peer saves received chunks</p> </li> <li> <p>Transfer Completion:</p> </li> <li>All chunks received and verified</li> <li>Transfer marked as completed</li> <li>File available for reassembly</li> </ol>"},{"location":"advanced/webrtc_implementation/#error-handling","title":"Error Handling","text":"<p>FuryMesh implements comprehensive error handling:</p>"},{"location":"advanced/webrtc_implementation/#timeout-handling","title":"Timeout Handling","text":"<pre><code>// Wait for chunk to be received or timeout\ntimeout := time.After(w.config.IdleTimeout)\nticker := time.NewTicker(100 * time.Millisecond)\ndefer ticker.Stop()\n\nchunkWaitLoop:\nfor {\n    select {\n    case &lt;-ctx.Done():\n        return\n    case &lt;-timeout:\n        // Timeout waiting for chunk\n        w.logger.Warn(\"Timeout waiting for chunk\",\n            zap.String(\"transferID\", transfer.ID),\n            zap.String(\"fileID\", metadata.FileID),\n            zap.Int(\"chunkIndex\", chunkIndex))\n        break chunkWaitLoop\n    case &lt;-ticker.C:\n        // Check if chunk has been received\n        _, err := w.fileManager.GetStorageManager().GetChunk(metadata.FileID, chunkIndex)\n        if err == nil {\n            // Chunk received\n            return\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/webrtc_implementation/#retry-mechanism","title":"Retry Mechanism","text":"<p>FuryMesh implements automatic retries for failed chunk transfers:</p> <pre><code>// Retry logic\nfor retry := 0; retry &lt; w.config.MaxRetries; retry++ {\n    // Request chunk\n    err := w.requestFileChunk(peerID, fileID, chunkIndex)\n    if err != nil {\n        // Handle error\n        continue\n    }\n\n    // Wait for chunk...\n}\n</code></pre>"},{"location":"advanced/webrtc_implementation/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/webrtc_implementation/#chunk-selection-strategies","title":"Chunk Selection Strategies","text":"<p>FuryMesh implements different strategies for selecting which chunks to request:</p> <ul> <li>Round Robin: Distributes chunk requests evenly among peers</li> <li>Rarest First: Requests the rarest chunks first</li> <li>Sequential: Requests chunks in sequential order</li> </ul>"},{"location":"advanced/webrtc_implementation/#concurrent-transfers","title":"Concurrent Transfers","text":"<p>FuryMesh optimizes transfers by requesting multiple chunks simultaneously:</p> <pre><code>// Create a semaphore to limit concurrent requests\nsem := make(chan struct{}, w.config.MaxConcurrentChunks)\n\n// Request chunks concurrently\nfor _, chunkIndex := range chunksToRequest {\n    sem &lt;- struct{}{} // Acquire semaphore\n    go func(idx int) {\n        defer func() { &lt;-sem }() // Release semaphore\n        // Request and process chunk\n    }(chunkIndex)\n}\n</code></pre>"},{"location":"advanced/webrtc_implementation/#integration-with-file-system","title":"Integration with File System","text":"<p>The WebRTC components integrate with the file system through the <code>FileManager</code>:</p> <pre><code>// FileManager integrates file operations with the node\ntype FileManager struct {\n    logger          *zap.Logger\n    chunker         *file.Chunker\n    storageManager  *file.StorageManager\n    transferManager *file.TransferManager\n    webrtcTransport *file.WebRTCTransportAdapter\n\n    // Other fields...\n}\n</code></pre>"},{"location":"advanced/webrtc_implementation/#security-implementation","title":"Security Implementation","text":""},{"location":"advanced/webrtc_implementation/#data-channel-encryption","title":"Data Channel Encryption","text":"<p>WebRTC data channels are automatically encrypted using DTLS:</p> <pre><code>// WebRTC configuration\nconfig := webrtc.Configuration{\n    ICEServers:         iceServers,\n    ICETransportPolicy: webrtc.ICETransportPolicyAll,\n    BundlePolicy:       webrtc.BundlePolicyBalanced,\n    RTCPMuxPolicy:      webrtc.RTCPMuxPolicyRequire,\n}\n</code></pre>"},{"location":"advanced/webrtc_implementation/#content-encryption","title":"Content Encryption","text":"<p>Optional content encryption is implemented using the <code>crypto</code> package:</p> <pre><code>// Encrypt chunk data if encryption is enabled\nif encryptionMgr != nil {\n    encryptedData, err := encryptionMgr.EncryptData(data)\n    if err != nil {\n        return err\n    }\n    data = encryptedData\n}\n</code></pre>"},{"location":"advanced/webrtc_implementation/#debugging-and-monitoring","title":"Debugging and Monitoring","text":"<p>FuryMesh provides extensive logging and metrics for debugging:</p> <pre><code>// Log transfer completion\nw.logger.Info(\"Transfer completed\",\n    zap.String(\"file_id\", transfer.FileID),\n    zap.String(\"peer_id\", transfer.PeerID),\n    zap.Int(\"total_chunks\", transfer.TotalChunks),\n    zap.Int64(\"bytes\", transfer.BytesTransferred),\n    zap.Float64(\"rate_bps\", transfer.TransferRate))\n</code></pre>"},{"location":"advanced/webrtc_implementation/#configuration-reference","title":"Configuration Reference","text":"<p>Complete configuration reference for WebRTC in FuryMesh:</p> <pre><code>webrtc:\n  # STUN servers for NAT traversal\n  stun_servers:\n    - \"stun:stun.l.google.com:19302\"\n    - \"stun:stun1.l.google.com:19302\"\n\n  # TURN servers for fallback relay\n  turn_servers: []\n  username: \"\"\n  credential: \"\"\n\n  # ICE timeout in seconds\n  ice_timeout: 30\n\n  # Maximum connection retries\n  max_retries: 3\n\ntransfer:\n  # Chunk size in bytes (1MB default)\n  chunk_size: 1048576\n\n  # Maximum concurrent chunk transfers\n  max_concurrent_chunks: 5\n\n  # Retry interval for failed transfers\n  retry_interval: 5s\n\n  # Maximum retry attempts\n  max_retries: 3\n\n  # Idle timeout for stalled transfers\n  idle_timeout: 30s\n\n  # Buffer size for prefetching chunks\n  buffer_size: 10\n</code></pre>"},{"location":"api-reference/","title":"API Reference","text":"<p>FuryMesh provides a comprehensive REST API that allows you to integrate with and control FuryMesh programmatically. This reference documents all available endpoints, request parameters, and response formats.</p>"},{"location":"api-reference/#api-overview","title":"API Overview","text":"<p>The FuryMesh API is available when you start FuryMesh with the <code>--enable-api</code> flag:</p> <pre><code>furymesh start --enable-api --api-port 8081\n</code></pre> <p>By default, the API listens on <code>http://localhost:8081</code>. All API endpoints return JSON responses.</p>"},{"location":"api-reference/#authentication","title":"Authentication","text":"<p>API requests can be authenticated using an API key:</p> <pre><code>curl -H \"Authorization: Bearer YOUR_API_KEY\" http://localhost:8081/api/v1/files\n</code></pre> <p>To generate an API key:</p> <pre><code>furymesh generate-api-key\n</code></pre>"},{"location":"api-reference/#endpoints","title":"Endpoints","text":""},{"location":"api-reference/#node-management","title":"Node Management","text":""},{"location":"api-reference/#get-apiv1nodeinfo","title":"GET /api/v1/node/info","text":"<p>Returns information about the current node.</p> <p>Response:</p> <pre><code>{\n  \"node_id\": \"QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG\",\n  \"version\": \"1.0.0\",\n  \"uptime\": 3600,\n  \"peers_connected\": 5,\n  \"storage_used\": 1024000,\n  \"storage_available\": 10240000000\n}\n</code></pre>"},{"location":"api-reference/#get-apiv1nodepeers","title":"GET /api/v1/node/peers","text":"<p>Lists all connected peers.</p> <p>Response:</p> <pre><code>{\n  \"peers\": [\n    {\n      \"id\": \"QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG\",\n      \"address\": \"203.0.113.1:8080\",\n      \"connected_since\": \"2023-01-01T12:00:00Z\",\n      \"files_available\": 10\n    },\n    {\n      \"id\": \"QmZTR5bcpQD7cFgTorqxZDYaew1Wqgfbd2ud9QqGPAkK2V\",\n      \"address\": \"203.0.113.2:8080\",\n      \"connected_since\": \"2023-01-01T12:30:00Z\",\n      \"files_available\": 5\n    }\n  ]\n}\n</code></pre>"},{"location":"api-reference/#file-management","title":"File Management","text":""},{"location":"api-reference/#get-apiv1files","title":"GET /api/v1/files","text":"<p>Lists all files available locally.</p> <p>Response:</p> <pre><code>{\n  \"files\": [\n    {\n      \"id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n      \"name\": \"example.txt\",\n      \"size\": 1024,\n      \"chunks\": 2,\n      \"created_at\": \"2023-01-01T12:00:00Z\",\n      \"complete\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"api-reference/#post-apiv1filesshare","title":"POST /api/v1/files/share","text":"<p>Shares a file on the network.</p> <p>Request:</p> <pre><code>{\n  \"file_path\": \"/path/to/file.txt\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"file_id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n  \"name\": \"file.txt\",\n  \"size\": 1024,\n  \"chunks\": 2\n}\n</code></pre>"},{"location":"api-reference/#get-apiv1filesnetwork","title":"GET /api/v1/files/network","text":"<p>Lists all files available on the network.</p> <p>Response:</p> <pre><code>{\n  \"files\": [\n    {\n      \"id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n      \"name\": \"example.txt\",\n      \"size\": 1024,\n      \"peers\": [\"QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"api-reference/#delete-apiv1filesfile_id","title":"DELETE /api/v1/files/{file_id}","text":"<p>Deletes a file from local storage.</p> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"message\": \"File deleted successfully\"\n}\n</code></pre>"},{"location":"api-reference/#transfer-management","title":"Transfer Management","text":""},{"location":"api-reference/#post-apiv1transfersdownload","title":"POST /api/v1/transfers/download","text":"<p>Starts downloading a file.</p> <p>Request:</p> <pre><code>{\n  \"file_id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n  \"output_path\": \"/path/to/save/file.txt\",\n  \"multi_peer\": true\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"transfer_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"file_id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n  \"status\": \"started\"\n}\n</code></pre>"},{"location":"api-reference/#get-apiv1transfers","title":"GET /api/v1/transfers","text":"<p>Lists all active transfers.</p> <p>Response:</p> <pre><code>{\n  \"transfers\": [\n    {\n      \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n      \"file_id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n      \"status\": \"in_progress\",\n      \"progress\": 0.5,\n      \"speed\": 1048576,\n      \"peers\": 2,\n      \"started_at\": \"2023-01-01T12:00:00Z\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api-reference/#get-apiv1transferstransfer_id","title":"GET /api/v1/transfers/{transfer_id}","text":"<p>Gets information about a specific transfer.</p> <p>Response:</p> <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"file_id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n  \"status\": \"in_progress\",\n  \"progress\": 0.5,\n  \"speed\": 1048576,\n  \"peers\": [\n    {\n      \"id\": \"QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG\",\n      \"chunks_downloaded\": 1,\n      \"speed\": 524288\n    },\n    {\n      \"id\": \"QmZTR5bcpQD7cFgTorqxZDYaew1Wqgfbd2ud9QqGPAkK2V\",\n      \"chunks_downloaded\": 0,\n      \"speed\": 524288\n    }\n  ],\n  \"started_at\": \"2023-01-01T12:00:00Z\",\n  \"estimated_completion\": \"2023-01-01T12:01:00Z\"\n}\n</code></pre>"},{"location":"api-reference/#post-apiv1transferstransfer_idcancel","title":"POST /api/v1/transfers/{transfer_id}/cancel","text":"<p>Cancels an active transfer.</p> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"message\": \"Transfer cancelled\"\n}\n</code></pre>"},{"location":"api-reference/#post-apiv1transfersresumefile_id","title":"POST /api/v1/transfers/resume/{file_id}","text":"<p>Resumes a previously interrupted transfer.</p> <p>Response:</p> <pre><code>{\n  \"transfer_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"file_id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n  \"status\": \"resumed\",\n  \"progress\": 0.5\n}\n</code></pre>"},{"location":"api-reference/#system-management","title":"System Management","text":""},{"location":"api-reference/#get-apiv1systemstats","title":"GET /api/v1/system/stats","text":"<p>Returns system statistics.</p> <p>Response:</p> <pre><code>{\n  \"cpu_usage\": 0.2,\n  \"memory_usage\": 104857600,\n  \"disk_usage\": 1073741824,\n  \"network\": {\n    \"upload_speed\": 1048576,\n    \"download_speed\": 2097152,\n    \"total_uploaded\": 10485760,\n    \"total_downloaded\": 20971520\n  }\n}\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>All API errors follow a standard format:</p> <pre><code>{\n  \"error\": true,\n  \"code\": 404,\n  \"message\": \"File not found\"\n}\n</code></pre> <p>Common error codes:</p> <ul> <li><code>400</code>: Bad Request - The request was malformed</li> <li><code>401</code>: Unauthorized - Authentication is required</li> <li><code>403</code>: Forbidden - The request is not allowed</li> <li><code>404</code>: Not Found - The requested resource does not exist</li> <li><code>500</code>: Internal Server Error - Something went wrong on the server</li> </ul>"},{"location":"api-reference/#rate-limiting","title":"Rate Limiting","text":"<p>API requests are rate-limited to 100 requests per minute per IP address. When the rate limit is exceeded, the API returns a <code>429 Too Many Requests</code> response.</p>"},{"location":"api-reference/#webhooks","title":"Webhooks","text":"<p>FuryMesh can send webhook notifications for various events. Configure webhooks using:</p> <pre><code>furymesh start --webhook-url \"https://example.com/webhook\" --webhook-events \"transfer_complete,peer_connected\"\n</code></pre> <p>Webhook payloads follow this format:</p> <pre><code>{\n  \"event\": \"transfer_complete\",\n  \"timestamp\": \"2023-01-01T12:00:00Z\",\n  \"data\": {\n    \"file_id\": \"QmZ4tDuvesekSs4qM5ZBKpXiZGun7S2CYtEZRB3DYXkjGx\",\n    \"size\": 1024,\n    \"duration\": 60\n  }\n}\n</code></pre>"},{"location":"api-reference/#client-libraries","title":"Client Libraries","text":"<p>FuryMesh provides official client libraries for easy integration:</p> <ul> <li>JavaScript/Node.js</li> <li>Python</li> <li>Go</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>This page documents all notable changes to FuryMesh.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for custom storage backends</li> <li>Improved logging with structured output</li> <li>New metrics for monitoring transfer performance</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Optimized chunk selection algorithm for multi-peer transfers</li> <li>Enhanced error handling for network failures</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Issue with resume data corruption when transfers are interrupted multiple times</li> <li>Memory leak in the WebRTC connection handling</li> </ul>"},{"location":"changelog/#100-2023-03-01","title":"[1.0.0] - 2023-03-01","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial stable release</li> <li>Multi-peer transfer support</li> <li>Resume capability for interrupted transfers</li> <li>End-to-end encryption for all file transfers</li> <li>WebRTC transport for NAT traversal</li> <li>DHT-based peer discovery</li> <li>Command-line interface</li> <li>Basic REST API</li> <li>Local file storage and management</li> <li>Transfer statistics and monitoring</li> </ul>"},{"location":"changelog/#090-2023-02-15","title":"[0.9.0] - 2023-02-15","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Beta release with core functionality</li> <li>Basic multi-peer transfer support</li> <li>Initial implementation of resume capability</li> <li>End-to-end encryption</li> <li>WebRTC transport</li> <li>DHT-based peer discovery</li> <li>Command-line interface</li> </ul>"},{"location":"changelog/#known-issues","title":"Known Issues","text":"<ul> <li>Occasional connection issues with certain NAT configurations</li> <li>Limited error recovery for interrupted transfers</li> <li>Performance bottlenecks with large files</li> </ul>"},{"location":"changelog/#080-2023-01-30","title":"[0.8.0] - 2023-01-30","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Alpha release for early testing</li> <li>Single-peer file transfers</li> <li>Basic WebRTC implementation</li> <li>Simple DHT for peer discovery</li> <li>Command-line interface for basic operations</li> </ul>"},{"location":"changelog/#known-issues_1","title":"Known Issues","text":"<ul> <li>No multi-peer support</li> <li>No resume capability</li> <li>Limited encryption options</li> <li>Unstable connections in complex network environments</li> </ul>"},{"location":"changelog/#070-2023-01-15","title":"[0.7.0] - 2023-01-15","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Pre-alpha developer preview</li> <li>Proof-of-concept implementation</li> <li>Basic file chunking and transfer</li> <li>Simplified peer discovery</li> <li>Minimal command-line interface</li> </ul>"},{"location":"changelog/#release-process","title":"Release Process","text":"<p>FuryMesh follows Semantic Versioning. Each release goes through the following stages:</p> <ol> <li>Feature Freeze: No new features are added, only bug fixes</li> <li>Release Candidate: Testing and stabilization</li> <li>Final Release: Stable version released to the public</li> </ol>"},{"location":"changelog/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"changelog/#upgrading-from-0x-to-10","title":"Upgrading from 0.x to 1.0","text":"<ol> <li>Backup your configuration and data:</li> </ol> <pre><code>cp -r ~/.furymesh ~/.furymesh.backup\n</code></pre> <ol> <li>Install the new version:</li> </ol> <pre><code>go install github.com/TFMV/furymesh@latest\n</code></pre> <ol> <li>Start FuryMesh with your existing configuration:</li> </ol> <pre><code>furymesh start --config ~/.furymesh/config.yaml\n</code></pre> <ol> <li>Verify that your files and peers are correctly loaded:</li> </ol> <pre><code>furymesh list-files\nfurymesh list-peers\n</code></pre>"},{"location":"changelog/#upgrading-between-1x-versions","title":"Upgrading between 1.x versions","text":"<ol> <li>Backup your configuration:</li> </ol> <pre><code>cp ~/.furymesh/config.yaml ~/.furymesh/config.yaml.backup\n</code></pre> <ol> <li>Install the new version:</li> </ol> <pre><code>go install github.com/TFMV/furymesh@latest\n</code></pre> <ol> <li>Start FuryMesh:</li> </ol> <pre><code>furymesh start\n</code></pre>"},{"location":"changelog/#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter any issues after upgrading, please report them on GitHub with the following information:</p> <ul> <li>FuryMesh version you upgraded from</li> <li>FuryMesh version you upgraded to</li> <li>Operating system and version</li> <li>Any error messages or logs</li> <li>Steps to reproduce the issue</li> </ul>"},{"location":"contributing/","title":"Contributing to FuryMesh","text":"<p>Thank you for your interest in contributing to FuryMesh! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to abide by our Code of Conduct. Please read it before contributing.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.18 or higher</li> <li>Git</li> <li>Basic understanding of P2P networks and distributed systems</li> </ul>"},{"location":"contributing/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone https://github.com/YOUR-USERNAME/furymesh.git\ncd furymesh\n</code></pre> <ol> <li>Add the original repository as an upstream remote:</li> </ol> <pre><code>git remote add upstream https://github.com/TFMV/furymesh.git\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code>go mod download\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#branching-strategy","title":"Branching Strategy","text":"<ul> <li><code>main</code> - stable releases</li> <li><code>develop</code> - development branch</li> <li>Feature branches - named as <code>feature/your-feature-name</code></li> <li>Bugfix branches - named as <code>bugfix/issue-description</code></li> </ul>"},{"location":"contributing/#creating-a-new-feature","title":"Creating a New Feature","text":"<ol> <li>Sync your local repository with the upstream:</li> </ol> <pre><code>git checkout develop\ngit pull upstream develop\n</code></pre> <ol> <li>Create a new branch for your feature:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li>Make your changes and commit them with clear, descriptive messages:</li> </ol> <pre><code>git commit -m \"Add feature: description of your feature\"\n</code></pre> <ol> <li>Push your branch to your fork:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Create a Pull Request from your fork to the <code>develop</code> branch of the main repository</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>FuryMesh follows the standard Go style guidelines. Please ensure your code:</p> <ul> <li>Is formatted with <code>gofmt</code></li> <li>Passes <code>golint</code> and <code>go vet</code></li> <li>Includes appropriate comments and documentation</li> <li>Has meaningful variable and function names</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All new features and bug fixes should include tests. Run the test suite with:</p> <pre><code>go test ./...\n</code></pre> <p>For more comprehensive testing, including integration tests:</p> <pre><code>make test\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure your code follows the style guidelines and passes all tests</li> <li>Update the documentation if necessary</li> <li>Include a clear description of the changes in your PR</li> <li>Link any related issues in your PR description</li> <li>Wait for a maintainer to review your PR</li> <li>Address any feedback from the review</li> <li>Once approved, a maintainer will merge your PR</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is crucial for FuryMesh. If you're adding a new feature, please update:</p> <ul> <li>Code comments</li> <li>README.md (if applicable)</li> <li>Documentation in the <code>docs/</code> directory</li> </ul> <p>To build and preview the documentation locally:</p> <pre><code>cd python/furymesh\nmkdocs serve\n</code></pre> <p>Then visit <code>http://localhost:8000</code> in your browser.</p>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>When reporting bugs, please include:</p> <ul> <li>A clear, descriptive title</li> <li>Steps to reproduce the issue</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>FuryMesh version</li> <li>Operating system and version</li> <li>Any relevant logs or error messages</li> </ul>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<p>Feature requests are welcome! Please provide:</p> <ul> <li>A clear description of the feature</li> <li>The motivation behind the feature</li> <li>Potential implementation details (if you have ideas)</li> </ul>"},{"location":"contributing/#community","title":"Community","text":"<p>Join our community channels to discuss development:</p> <ul> <li>Discord</li> <li>Discussions on GitHub</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to FuryMesh, you agree that your contributions will be licensed under the project's MIT License.</p>"},{"location":"features/multi-peer-transfers/","title":"Multi-Peer Transfers","text":"<p>One of FuryMesh's most powerful features is the ability to download different chunks of a file from multiple peers simultaneously. This approach, similar to BitTorrent's swarming technique, significantly improves download speeds and resilience against peer disconnections.</p>"},{"location":"features/multi-peer-transfers/#how-it-works","title":"How It Works","text":"<p>When downloading a file using multi-peer transfers, FuryMesh:</p> <ol> <li>Discovers multiple peers that have the requested file</li> <li>Determines which chunks each peer has available</li> <li>Uses a chunk selection strategy to decide which chunks to request from which peers</li> <li>Downloads chunks in parallel from multiple peers</li> <li>Reassembles the chunks into the complete file</li> </ol> <p>This approach offers several advantages:</p> <ul> <li>Faster Downloads: By downloading from multiple sources simultaneously, you can achieve higher aggregate bandwidth</li> <li>Improved Reliability: If one peer disconnects or slows down, other peers can compensate</li> <li>Better Network Utilization: Distributes the load across multiple peers, preventing any single peer from becoming a bottleneck</li> </ul>"},{"location":"features/multi-peer-transfers/#using-multi-peer-transfers","title":"Using Multi-Peer Transfers","text":""},{"location":"features/multi-peer-transfers/#basic-usage","title":"Basic Usage","text":"<p>To download a file from multiple peers using the command line:</p> <pre><code># Download a file using multi-peer transfers\nfurymesh download --file-id &lt;file-id&gt; --multi-peer --output /path/to/output\n</code></pre> <p>This command will:</p> <ol> <li>Search the network for peers that have the specified file</li> <li>Establish connections with multiple peers</li> <li>Download different chunks from different peers simultaneously</li> <li>Reassemble the chunks into the complete file</li> </ol> <p>You can monitor the progress of the download:</p> <pre><code>Searching for peers with file 3f7b8a1c2d9e4f5a6b7c8d9e0f1a2b3c...\nFound 5 peers with the file.\nUsing multi-peer transfer with Rarest First strategy.\nDownloading from peers: peer1, peer2, peer3, peer4, peer5\n\nProgress: [====================] 100% Complete\nChunks: 20/20 (5 from peer1, 4 from peer2, 4 from peer3, 3 from peer4, 4 from peer5)\nAverage speed: 5.2 MB/s\nFile saved to /path/to/output/file.txt\n</code></pre>"},{"location":"features/multi-peer-transfers/#configuring-multi-peer-transfers","title":"Configuring Multi-Peer Transfers","text":"<p>You can configure multi-peer transfers in your configuration file:</p> <pre><code># config.yaml\ntransfer:\n  # Enable or disable multi-peer transfers\n  multi_peer_enabled: true\n  # Maximum number of peers to use for a single transfer\n  max_peers_per_transfer: 5\n  # Chunk selection strategy (rarest_first or round_robin)\n  chunk_selection_strategy: \"rarest_first\"\n</code></pre> <p>Start FuryMesh with this configuration:</p> <pre><code>furymesh start --config config.yaml\n</code></pre>"},{"location":"features/multi-peer-transfers/#command-line-options","title":"Command Line Options","text":"<p>When using the <code>download</code> command, you can specify several options for multi-peer transfers:</p> <pre><code># Download with a specific maximum number of peers\nfurymesh download --file-id &lt;file-id&gt; --multi-peer --max-peers 3 --output /path/to/output\n\n# Download with a specific chunk selection strategy\nfurymesh download --file-id &lt;file-id&gt; --multi-peer --strategy round_robin --output /path/to/output\n\n# Download with specific peers (in addition to auto-discovered peers)\nfurymesh download --file-id &lt;file-id&gt; --multi-peer --peers peer1,peer2,peer3 --output /path/to/output\n</code></pre>"},{"location":"features/multi-peer-transfers/#chunk-selection-strategies","title":"Chunk Selection Strategies","text":"<p>FuryMesh implements two chunk selection strategies that determine which chunks to request from which peers:</p>"},{"location":"features/multi-peer-transfers/#rarest-first-strategy","title":"Rarest First Strategy","text":"<p>The Rarest First strategy prioritizes downloading the rarest chunks first. This approach helps ensure that rare chunks are downloaded before common ones, which can improve the overall availability of the file in the network.</p> <p>To use the Rarest First strategy:</p> <pre><code>furymesh download --file-id &lt;file-id&gt; --multi-peer --strategy rarest_first --output /path/to/output\n</code></pre> <p>Or in your configuration file:</p> <pre><code>transfer:\n  chunk_selection_strategy: \"rarest_first\"\n</code></pre>"},{"location":"features/multi-peer-transfers/#round-robin-strategy","title":"Round Robin Strategy","text":"<p>The Round Robin strategy distributes chunk requests evenly across all available peers. This is a simple approach that works well when all peers have similar bandwidth and reliability.</p> <p>To use the Round Robin strategy:</p> <pre><code>furymesh download --file-id &lt;file-id&gt; --multi-peer --strategy round_robin --output /path/to/output\n</code></pre> <p>Or in your configuration file:</p> <pre><code>transfer:\n  chunk_selection_strategy: \"round_robin\"\n</code></pre>"},{"location":"features/multi-peer-transfers/#performance-considerations","title":"Performance Considerations","text":""},{"location":"features/multi-peer-transfers/#optimal-number-of-peers","title":"Optimal Number of Peers","text":"<p>While downloading from multiple peers can improve performance, there is a point of diminishing returns. Too many peers can lead to overhead in connection management and chunk coordination.</p> <p>In general, 3-5 peers is a good starting point for most scenarios. For very large files or in networks with high latency, you might benefit from more peers.</p> <p>You can specify the maximum number of peers to use:</p> <pre><code>furymesh download --file-id &lt;file-id&gt; --multi-peer --max-peers 5 --output /path/to/output\n</code></pre> <p>Or in your configuration file:</p> <pre><code>transfer:\n  max_peers_per_transfer: 5\n</code></pre>"},{"location":"features/multi-peer-transfers/#network-conditions","title":"Network Conditions","text":"<p>The effectiveness of multi-peer transfers depends on network conditions:</p> <ul> <li>Bandwidth: If your download bandwidth is already saturated by a single peer, adding more peers may not help</li> <li>Latency: In high-latency networks, multiple peers can help by allowing parallel requests</li> <li>Reliability: In networks with frequent disconnections, multiple peers provide redundancy</li> </ul>"},{"location":"features/multi-peer-transfers/#chunk-size","title":"Chunk Size","text":"<p>The chunk size affects the efficiency of multi-peer transfers:</p> <ul> <li>Smaller chunks: Allow for more granular distribution among peers but increase overhead</li> <li>Larger chunks: Reduce overhead but may lead to less optimal distribution</li> </ul> <p>The default chunk size (1MB) works well for most scenarios, but you can adjust it in the configuration:</p> <pre><code>transfer:\n  chunk_size: 1048576  # 1MB\n</code></pre>"},{"location":"features/multi-peer-transfers/#combining-with-resume-support","title":"Combining with Resume Support","text":"<p>Multi-peer transfers work seamlessly with FuryMesh's Resume Support. If a transfer is interrupted, you can resume it later, and FuryMesh will continue downloading from multiple peers.</p> <pre><code># Resume a multi-peer transfer\nfurymesh resume --file-id &lt;file-id&gt; --multi-peer\n</code></pre>"},{"location":"features/multi-peer-transfers/#viewing-transfer-statistics","title":"Viewing Transfer Statistics","text":"<p>You can view detailed statistics about your multi-peer transfers:</p> <pre><code>furymesh status --file-id &lt;file-id&gt; --verbose\n</code></pre> <p>This will show information about which chunks were downloaded from which peers, transfer rates, and more:</p> <pre><code>Transfer Status for file 3f7b8a1c2d9e4f5a6b7c8d9e0f1a2b3c:\nStatus: In Progress\nProgress: 65% (13/20 chunks)\nTotal Size: 20.5 MB\nDownloaded: 13.3 MB\nAverage Speed: 4.8 MB/s\n\nPeer Statistics:\n- peer1: 4 chunks, 4.1 MB, 5.2 MB/s\n- peer2: 3 chunks, 3.1 MB, 4.5 MB/s\n- peer3: 3 chunks, 3.1 MB, 4.8 MB/s\n- peer4: 2 chunks, 2.0 MB, 4.2 MB/s\n- peer5: 1 chunks, 1.0 MB, 3.9 MB/s\n\nChunk Distribution:\n[X][X][X][X][X][X][X][X][X][X][X][X][X][_][_][_][_][_][_][_]\n</code></pre>"},{"location":"features/multi-peer-transfers/#conclusion","title":"Conclusion","text":"<p>Multi-peer transfers are a powerful feature that can significantly improve download speeds and reliability. By distributing the load across multiple peers and using intelligent chunk selection strategies, FuryMesh ensures efficient and resilient file transfers.</p>"},{"location":"features/resume-support/","title":"Resume Support","text":"<p>FuryMesh includes robust support for resuming interrupted file transfers, allowing you to continue downloads from where they left off rather than starting over. This feature is particularly valuable for large files or in environments with unreliable connections.</p>"},{"location":"features/resume-support/#how-it-works","title":"How It Works","text":"<p>When a file transfer is in progress, FuryMesh:</p> <ol> <li>Tracks which chunks have been successfully downloaded</li> <li>Periodically saves this information to a resume data file</li> <li>If the transfer is interrupted, the resume data can be used to continue the transfer later</li> </ol> <p>When resuming a transfer, FuryMesh:</p> <ol> <li>Loads the resume data for the file</li> <li>Identifies which chunks have already been downloaded</li> <li>Requests only the missing chunks from peers</li> <li>Continues the transfer from where it left off</li> </ol>"},{"location":"features/resume-support/#using-resume-support","title":"Using Resume Support","text":""},{"location":"features/resume-support/#basic-usage","title":"Basic Usage","text":"<p>If a transfer is interrupted (for example, if you close FuryMesh or lose your internet connection), you can resume it using the <code>resume</code> command:</p> <pre><code># Resume a transfer\nfurymesh resume --file-id &lt;file-id&gt;\n</code></pre> <p>FuryMesh will automatically detect which chunks have already been downloaded and will only request the missing ones.</p> <p>You can monitor the progress of the resumed transfer:</p> <pre><code>Resuming transfer for file 3f7b8a1c2d9e4f5a6b7c8d9e0f1a2b3c...\nFound resume data: 13/20 chunks already downloaded (65%)\nRequesting remaining 7 chunks...\n\nProgress: [====================] 100% Complete\nFile saved to /path/to/output/file.txt\n</code></pre>"},{"location":"features/resume-support/#combining-with-multi-peer-transfers","title":"Combining with Multi-Peer Transfers","text":"<p>Resume support works seamlessly with Multi-Peer Transfers. When resuming a transfer, FuryMesh can download the remaining chunks from multiple peers:</p> <pre><code># Resume a transfer using multiple peers\nfurymesh resume --file-id &lt;file-id&gt; --multi-peer\n</code></pre>"},{"location":"features/resume-support/#configuring-resume-support","title":"Configuring Resume Support","text":"<p>You can configure resume support in your configuration file:</p> <pre><code># config.yaml\ntransfer:\n  # Enable or disable resume support\n  resume_enabled: true\n  # Directory to store resume data\n  resume_dir: \"./data/resume\"\n  # How often to save resume data (in seconds)\n  resume_save_interval: 30\n</code></pre> <p>Start FuryMesh with this configuration:</p> <pre><code>furymesh start --config config.yaml\n</code></pre>"},{"location":"features/resume-support/#command-line-options","title":"Command Line Options","text":"<p>When using the <code>resume</code> command, you can specify several options:</p> <pre><code># Resume a transfer with a specific output path\nfurymesh resume --file-id &lt;file-id&gt; --output /path/to/output\n\n# Resume a transfer with a specific peer\nfurymesh resume --file-id &lt;file-id&gt; --peer-id &lt;peer-id&gt;\n\n# Resume a transfer with verbose output\nfurymesh resume --file-id &lt;file-id&gt; --verbose\n</code></pre>"},{"location":"features/resume-support/#viewing-resume-data","title":"Viewing Resume Data","text":"<p>You can view information about available resume data:</p> <pre><code>furymesh list-resume\n</code></pre> <p>This will show all files that have resume data available:</p> <pre><code>+----------------------------------+-------------+----------+-------+------------+\n| File ID                          | Name        | Size     | Chunks | Progress   |\n+----------------------------------+-------------+----------+-------+------------+\n| 3f7b8a1c2d9e4f5a6b7c8d9e0f1a2b3c | file.txt    | 1.2 MB   | 5/10   | 50%        |\n| 7a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d | image.jpg   | 2.5 MB   | 8/10   | 80%        |\n+----------------------------------+-------------+----------+-------+------------+\n</code></pre> <p>For more detailed information about a specific file's resume data:</p> <pre><code>furymesh resume-info --file-id &lt;file-id&gt;\n</code></pre> <p>This will show detailed information about the resume data:</p> <pre><code>Resume Data for file 3f7b8a1c2d9e4f5a6b7c8d9e0f1a2b3c:\nFile Name: file.txt\nFile Size: 1.2 MB\nTotal Chunks: 10\nCompleted Chunks: 5 (50%)\nLast Updated: 2025-03-09 15:30:45\n\nChunk Status:\n[X][X][X][X][X][_][_][_][_][_]\n</code></pre>"},{"location":"features/resume-support/#cleaning-up-resume-data","title":"Cleaning Up Resume Data","text":"<p>Resume data is automatically deleted when a transfer is completed successfully. However, you can manually clean up resume data if needed:</p> <pre><code># Delete resume data for a specific file\nfurymesh clean-resume --file-id &lt;file-id&gt;\n\n# Delete all resume data\nfurymesh clean-resume --all\n</code></pre>"},{"location":"features/resume-support/#performance-considerations","title":"Performance Considerations","text":""},{"location":"features/resume-support/#storage-usage","title":"Storage Usage","text":"<p>Resume data is stored in the resume directory specified in your configuration. The amount of storage used is minimal, typically just a few kilobytes per file.</p>"},{"location":"features/resume-support/#resume-frequency","title":"Resume Frequency","text":"<p>By default, FuryMesh saves resume data every 30 seconds during a transfer and whenever a chunk is successfully downloaded. You can adjust this interval in the configuration:</p> <pre><code>transfer:\n  resume_save_interval: 60  # Save every 60 seconds\n</code></pre> <p>A shorter interval provides better protection against data loss but may cause more disk I/O.</p>"},{"location":"features/resume-support/#encryption","title":"Encryption","text":"<p>If you're using encryption for your transfers, the resume data will include information about the encryption keys used. When resuming an encrypted transfer, FuryMesh will automatically use the correct keys.</p>"},{"location":"features/resume-support/#troubleshooting","title":"Troubleshooting","text":""},{"location":"features/resume-support/#missing-resume-data","title":"Missing Resume Data","text":"<p>If resume data is missing or corrupted, FuryMesh will start the transfer from the beginning. This can happen if:</p> <ul> <li>The resume data file was deleted</li> <li>The resume data file was corrupted</li> <li>The resume feature was disabled when the original transfer was started</li> </ul>"},{"location":"features/resume-support/#incomplete-chunks","title":"Incomplete Chunks","text":"<p>If a chunk was partially downloaded when the transfer was interrupted, FuryMesh will request the entire chunk again. This ensures data integrity but may result in some redundant data transfer.</p>"},{"location":"features/resume-support/#changing-peers","title":"Changing Peers","text":"<p>When resuming a transfer, you can use different peers than the ones used in the original transfer. FuryMesh will request the missing chunks from the available peers, regardless of which peers were used originally.</p>"},{"location":"features/resume-support/#conclusion","title":"Conclusion","text":"<p>Resume support is a powerful feature that makes FuryMesh resilient to interruptions and network issues. By saving and restoring transfer state, it ensures that you can efficiently download files even in challenging network environments.</p>"},{"location":"features/webrtc/","title":"WebRTC Integration","text":"<p>FuryMesh leverages WebRTC technology to enable direct peer-to-peer file transfers without requiring centralized servers for data exchange. This document provides an overview of the WebRTC implementation in FuryMesh.</p>"},{"location":"features/webrtc/#architecture-overview","title":"Architecture Overview","text":"<p>The WebRTC implementation in FuryMesh consists of several key components:</p> <ol> <li>WebRTC Manager: Handles connection establishment and management</li> <li>WebRTC Messaging: Manages message exchange over data channels</li> <li>WebRTC Transfer Manager: Coordinates file transfers between peers</li> <li>WebRTC Transport Adapter: Bridges the file system with WebRTC components</li> </ol> <p>These components work together to provide a seamless peer-to-peer file sharing experience.</p>"},{"location":"features/webrtc/#connection-establishment","title":"Connection Establishment","text":"<p>FuryMesh uses a signaling mechanism to establish WebRTC connections between peers:</p> <ol> <li>Peers discover each other through the DHT (Distributed Hash Table)</li> <li>The signaling process exchanges SDP offers/answers and ICE candidates</li> <li>Once connected, peers communicate directly through WebRTC data channels</li> </ol>"},{"location":"features/webrtc/#file-transfer-process","title":"File Transfer Process","text":"<p>The file transfer process using WebRTC follows these steps:</p> <ol> <li>File Request: A peer requests a file from another peer</li> <li>Metadata Exchange: The source peer sends file metadata (size, chunks, etc.)</li> <li>Chunk Requests: The requesting peer requests individual chunks</li> <li>Data Transfer: Chunks are transferred directly between peers</li> <li>Reassembly: The receiving peer reassembles the file from chunks</li> </ol>"},{"location":"features/webrtc/#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<p>FuryMesh implements robust error handling for WebRTC transfers:</p> <ul> <li>Connection Monitoring: Continuously monitors connection state</li> <li>Timeout Handling: Implements timeouts for stalled transfers</li> <li>Retry Mechanism: Automatically retries failed chunk transfers</li> <li>Multi-peer Fallback: Can request chunks from multiple peers if available</li> </ul>"},{"location":"features/webrtc/#performance-optimizations","title":"Performance Optimizations","text":"<p>Several optimizations ensure efficient file transfers:</p> <ul> <li>Chunk Selection Strategies: Implements various strategies for requesting chunks</li> <li>Concurrent Transfers: Supports multiple simultaneous chunk transfers</li> <li>Buffer Management: Optimizes memory usage during transfers</li> <li>Binary Serialization: Uses FlatBuffers for efficient message encoding</li> </ul>"},{"location":"features/webrtc/#security-considerations","title":"Security Considerations","text":"<p>WebRTC connections in FuryMesh are secured through:</p> <ul> <li>Encrypted Data Channels: All WebRTC data channels use DTLS encryption</li> <li>Optional Content Encryption: File content can be additionally encrypted</li> <li>Peer Authentication: Verifies peer identity during connection establishment</li> </ul>"},{"location":"features/webrtc/#configuration-options","title":"Configuration Options","text":"<p>FuryMesh allows customization of WebRTC behavior through configuration:</p> <pre><code>webrtc:\n  stun_servers:\n    - \"stun:stun.l.google.com:19302\"\n    - \"stun:stun1.l.google.com:19302\"\n  turn_servers: []\n  username: \"\"\n  credential: \"\"\n  ice_timeout: 30\n  max_retries: 3\n\ntransfer:\n  chunk_size: 1048576  # 1MB\n  max_concurrent_chunks: 5\n  retry_interval: 5s\n  max_retries: 3\n  idle_timeout: 30s\n  buffer_size: 10\n</code></pre>"},{"location":"features/webrtc/#debugging-and-monitoring","title":"Debugging and Monitoring","text":"<p>FuryMesh provides tools for debugging WebRTC connections:</p> <ul> <li>Connection State Logging: Logs connection state changes</li> <li>Transfer Statistics: Tracks transfer progress and performance</li> <li>Metrics Collection: Gathers metrics on message exchange and data transfer</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>FuryMesh offers extensive configuration options to customize its behavior according to your needs. This guide covers all available configuration options and how to use them.</p>"},{"location":"getting-started/configuration/#configuration-file","title":"Configuration File","text":"<p>FuryMesh uses a YAML configuration file. By default, it looks for a file named <code>config.yaml</code> in the current directory, but you can specify a different path using the <code>--config</code> flag.</p> <p>Here's a complete example of a configuration file with all available options:</p> <pre><code># Node configuration\nnode:\n  # Unique identifier for this node\n  id: \"my-node\"\n  # Port to listen on for incoming connections\n  port: 8080\n  # Directory to store data\n  data_dir: \"./data\"\n  # Maximum number of concurrent connections\n  max_connections: 100\n  # Enable or disable debug mode\n  debug: false\n\n# DHT configuration\ndht:\n  # Known peers to bootstrap with\n  bootstrap_peers:\n    - \"peer1.example.com:8080\"\n    - \"peer2.example.com:8080\"\n  # Size of the routing table buckets\n  bucket_size: 20\n  # Alpha parameter for Kademlia (number of parallel lookups)\n  alpha: 3\n  # Interval for refreshing buckets (in seconds)\n  refresh_interval: 3600\n  # Timeout for DHT operations (in seconds)\n  operation_timeout: 30\n\n# WebRTC configuration\nwebrtc:\n  # STUN servers for NAT traversal\n  stun_servers:\n    - \"stun:stun.l.google.com:19302\"\n    - \"stun:stun1.l.google.com:19302\"\n  # TURN servers for fallback relay\n  turn_servers:\n    - url: \"turn:turn.example.com:3478\"\n      username: \"username\"\n      password: \"password\"\n  # ICE candidate gathering timeout (in seconds)\n  ice_gathering_timeout: 5\n  # Maximum message size (in bytes)\n  max_message_size: 65536\n\n# Transfer configuration\ntransfer:\n  # Number of concurrent transfers\n  concurrent_transfers: 5\n  # Size of each chunk (in bytes)\n  chunk_size: 1048576  # 1MB\n  # Maximum number of retries for failed chunks\n  max_retries: 3\n  # Request timeout (in seconds)\n  request_timeout: 30\n  # Enable or disable resume support\n  resume_enabled: true\n  # Directory to store resume data\n  resume_dir: \"./data/resume\"\n  # Chunk selection strategy (round_robin or rarest_first)\n  chunk_selection_strategy: \"rarest_first\"\n\n# Encryption configuration\nencryption:\n  # Enable or disable encryption\n  enabled: true\n  # Directory to store encryption keys\n  keys_dir: \"./data/keys\"\n  # Key size (in bits)\n  key_size: 2048\n  # Key expiration (in days)\n  key_expiration: 365\n\n# API configuration\napi:\n  # Enable or disable the API\n  enabled: true\n  # Port to listen on for API requests\n  port: 8081\n  # Enable or disable CORS\n  cors_enabled: true\n  # Allowed origins for CORS\n  cors_allowed_origins:\n    - \"*\"\n  # Enable or disable authentication\n  auth_enabled: false\n  # Authentication token\n  auth_token: \"\"\n\n# Logging configuration\nlogging:\n  # Log level (debug, info, warn, error)\n  level: \"info\"\n  # Log format (json or console)\n  format: \"console\"\n  # Log file path (empty for stdout)\n  file: \"\"\n  # Maximum log file size before rotation (in MB)\n  max_size: 100\n  # Maximum number of old log files to retain\n  max_backups: 5\n  # Maximum age of old log files (in days)\n  max_age: 30\n</code></pre>"},{"location":"getting-started/configuration/#loading-configuration","title":"Loading Configuration","text":"<p>You can load the configuration in your code:</p> <pre><code>package main\n\nimport (\n \"github.com/TFMV/furymesh/node\"\n \"go.uber.org/zap\"\n)\n\nfunc main() {\n logger, _ := zap.NewDevelopment()\n defer logger.Sync()\n\n // Load configuration from file\n config, err := node.LoadConfig(\"config.yaml\")\n if err != nil {\n  logger.Fatal(\"Failed to load config\", zap.Error(err))\n }\n\n // Create a node with the loaded configuration\n n, err := node.NewNodeWithConfig(logger, config)\n if err != nil {\n  logger.Fatal(\"Failed to create node\", zap.Error(err))\n }\n\n // Start the node\n if err := n.Start(); err != nil {\n  logger.Fatal(\"Failed to start node\", zap.Error(err))\n }\n defer n.Stop()\n\n // ...\n}\n</code></pre>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/configuration/#node-configuration","title":"Node Configuration","text":"Option Description Default <code>node.id</code> Unique identifier for this node Random UUID <code>node.port</code> Port to listen on for incoming connections 8080 <code>node.data_dir</code> Directory to store data \"./data\" <code>node.max_connections</code> Maximum number of concurrent connections 100 <code>node.debug</code> Enable or disable debug mode false"},{"location":"getting-started/configuration/#dht-configuration","title":"DHT Configuration","text":"Option Description Default <code>dht.bootstrap_peers</code> Known peers to bootstrap with [] <code>dht.bucket_size</code> Size of the routing table buckets 20 <code>dht.alpha</code> Alpha parameter for Kademlia (number of parallel lookups) 3 <code>dht.refresh_interval</code> Interval for refreshing buckets (in seconds) 3600 <code>dht.operation_timeout</code> Timeout for DHT operations (in seconds) 30"},{"location":"getting-started/configuration/#webrtc-configuration","title":"WebRTC Configuration","text":"Option Description Default <code>webrtc.stun_servers</code> STUN servers for NAT traversal [\"stun:stun.l.google.com:19302\"] <code>webrtc.turn_servers</code> TURN servers for fallback relay [] <code>webrtc.ice_gathering_timeout</code> ICE candidate gathering timeout (in seconds) 5 <code>webrtc.max_message_size</code> Maximum message size (in bytes) 65536"},{"location":"getting-started/configuration/#transfer-configuration","title":"Transfer Configuration","text":"Option Description Default <code>transfer.concurrent_transfers</code> Number of concurrent transfers 5 <code>transfer.chunk_size</code> Size of each chunk (in bytes) 1048576 (1MB) <code>transfer.max_retries</code> Maximum number of retries for failed chunks 3 <code>transfer.request_timeout</code> Request timeout (in seconds) 30 <code>transfer.resume_enabled</code> Enable or disable resume support true <code>transfer.resume_dir</code> Directory to store resume data \"./data/resume\" <code>transfer.chunk_selection_strategy</code> Chunk selection strategy (round_robin or rarest_first) \"rarest_first\""},{"location":"getting-started/configuration/#encryption-configuration","title":"Encryption Configuration","text":"Option Description Default <code>encryption.enabled</code> Enable or disable encryption true <code>encryption.keys_dir</code> Directory to store encryption keys \"./data/keys\" <code>encryption.key_size</code> Key size (in bits) 2048 <code>encryption.key_expiration</code> Key expiration (in days) 365"},{"location":"getting-started/configuration/#api-configuration","title":"API Configuration","text":"Option Description Default <code>api.enabled</code> Enable or disable the API true <code>api.port</code> Port to listen on for API requests 8081 <code>api.cors_enabled</code> Enable or disable CORS true <code>api.cors_allowed_origins</code> Allowed origins for CORS [\"*\"] <code>api.auth_enabled</code> Enable or disable authentication false <code>api.auth_token</code> Authentication token \"\""},{"location":"getting-started/configuration/#logging-configuration","title":"Logging Configuration","text":"Option Description Default <code>logging.level</code> Log level (debug, info, warn, error) \"info\" <code>logging.format</code> Log format (json or console) \"console\" <code>logging.file</code> Log file path (empty for stdout) \"\" <code>logging.max_size</code> Maximum log file size before rotation (in MB) 100 <code>logging.max_backups</code> Maximum number of old log files to retain 5 <code>logging.max_age</code> Maximum age of old log files (in days) 30"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>All configuration options can also be set using environment variables. The environment variable names are derived from the configuration keys by converting them to uppercase and replacing dots with underscores.</p> <p>For example:</p> <ul> <li><code>node.id</code> becomes <code>NODE_ID</code></li> <li><code>dht.bootstrap_peers</code> becomes <code>DHT_BOOTSTRAP_PEERS</code></li> <li><code>webrtc.stun_servers</code> becomes <code>WEBRTC_STUN_SERVERS</code></li> </ul> <p>For array values, use comma-separated strings:</p> <pre><code>export DHT_BOOTSTRAP_PEERS=\"peer1.example.com:8080,peer2.example.com:8080\"\nexport WEBRTC_STUN_SERVERS=\"stun:stun.l.google.com:19302,stun:stun1.l.google.com:19302\"\n</code></pre>"},{"location":"getting-started/configuration/#command-line-flags","title":"Command Line Flags","text":"<p>FuryMesh also supports command line flags for common configuration options:</p> <pre><code># Start a node with custom configuration\nfurymesh start --config /path/to/config.yaml --port 8080 --data-dir ./data\n</code></pre> <p>Available flags:</p> <ul> <li><code>--config</code>: Path to the configuration file</li> <li><code>--port</code>: Port to listen on for incoming connections</li> <li><code>--data-dir</code>: Directory to store data</li> <li><code>--debug</code>: Enable debug mode</li> <li><code>--log-level</code>: Log level (debug, info, warn, error)</li> <li><code>--bootstrap</code>: Comma-separated list of bootstrap peers</li> </ul> <p>Command line flags take precedence over environment variables and configuration file values.</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<p>Now that you understand how to configure FuryMesh, you can:</p> <ul> <li>Learn about Multi-Peer Transfers</li> <li>Understand Resume Support</li> <li>Explore the API Reference</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install FuryMesh on your system.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing FuryMesh, ensure you have the following prerequisites:</p> <ul> <li>Go 1.20 or later</li> <li>Git</li> <li>A C compiler (for some dependencies)</li> </ul>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from Source","text":""},{"location":"getting-started/installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/TFMV/furymesh.git\ncd furymesh\n</code></pre>"},{"location":"getting-started/installation/#build-the-application","title":"Build the Application","text":"<pre><code># Build the FuryMesh application\ngo build -o furymesh cmd/furymesh/main.go\n</code></pre>"},{"location":"getting-started/installation/#install-the-application-optional","title":"Install the Application (Optional)","text":"<p>To make FuryMesh available system-wide:</p> <pre><code># On Linux/macOS\nsudo cp furymesh /usr/local/bin/\n\n# On Windows (run as Administrator)\ncopy furymesh.exe C:\\Windows\\System32\\\n</code></pre>"},{"location":"getting-started/installation/#run-tests","title":"Run Tests","text":"<p>To ensure everything is working correctly, run the tests:</p> <pre><code>go test ./...\n</code></pre>"},{"location":"getting-started/installation/#using-pre-built-binaries","title":"Using Pre-built Binaries","text":"<p>You can download pre-built binaries for your platform from the releases page.</p>"},{"location":"getting-started/installation/#linux","title":"Linux","text":"<pre><code># Download the latest release\ncurl -L https://github.com/TFMV/furymesh/releases/latest/download/furymesh-linux-amd64.tar.gz -o furymesh.tar.gz\n\n# Extract the archive\ntar -xzf furymesh.tar.gz\n\n# Make the binary executable\nchmod +x furymesh\n\n# Move to a directory in your PATH (optional)\nsudo mv furymesh /usr/local/bin/\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code># Download the latest release\ncurl -L https://github.com/TFMV/furymesh/releases/latest/download/furymesh-darwin-amd64.tar.gz -o furymesh.tar.gz\n\n# Extract the archive\ntar -xzf furymesh.tar.gz\n\n# Make the binary executable\nchmod +x furymesh\n\n# Move to a directory in your PATH (optional)\nsudo mv furymesh /usr/local/bin/\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ol> <li>Download the latest release from the releases page</li> <li>Extract the ZIP file</li> <li>Run <code>furymesh.exe</code> from the command prompt or PowerShell</li> </ol>"},{"location":"getting-started/installation/#docker-installation","title":"Docker Installation","text":"<p>FuryMesh can also be run in a Docker container:</p> <pre><code># Pull the Docker image\ndocker pull tfmv/furymesh:latest\n\n# Run the container\ndocker run -p 8080:8080 -p 3478:3478/udp -v /path/to/data:/data tfmv/furymesh\n</code></pre>"},{"location":"getting-started/installation/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"getting-started/installation/#linux_1","title":"Linux","text":"<p>On Linux, you may need to install additional dependencies:</p> <pre><code># Ubuntu/Debian\nsudo apt-get update\nsudo apt-get install -y build-essential libssl-dev\n\n# CentOS/RHEL\nsudo yum install -y gcc openssl-devel\n</code></pre>"},{"location":"getting-started/installation/#macos_1","title":"macOS","text":"<p>On macOS, you can use Homebrew to install the required dependencies:</p> <pre><code>brew install go openssl\n</code></pre>"},{"location":"getting-started/installation/#windows_1","title":"Windows","text":"<p>On Windows, you'll need:</p> <ol> <li>Go</li> <li>Git for Windows</li> <li>MinGW or MSYS2</li> </ol>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify that FuryMesh is installed correctly, run:</p> <pre><code>furymesh --version\n</code></pre> <p>You should see output indicating the version of FuryMesh.</p>"},{"location":"getting-started/installation/#basic-usage","title":"Basic Usage","text":"<p>Once installed, you can start a FuryMesh node:</p> <pre><code># Start a node with default settings\nfurymesh start\n\n# Start a node with custom settings\nfurymesh start --port 8080 --data-dir ./data\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#build-errors","title":"Build Errors","text":"<p>If you encounter build errors related to CGO, try setting:</p> <pre><code>export CGO_ENABLED=1\n</code></pre>"},{"location":"getting-started/installation/#webrtc-issues","title":"WebRTC Issues","text":"<p>If you have issues with WebRTC connections:</p> <ol> <li>Ensure your firewall allows UDP traffic on the required ports</li> <li>Check that your STUN/TURN server configuration is correct</li> </ol>"},{"location":"getting-started/installation/#permission-issues","title":"Permission Issues","text":"<p>On Linux, if you encounter permission issues when binding to ports:</p> <pre><code># Run with elevated privileges for ports &lt; 1024\nsudo furymesh start --port 80\n\n# Or configure to use higher ports in the configuration file\nfurymesh start --port 8080\n</code></pre>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues not covered here, please:</p> <ol> <li>Check the GitHub Issues for similar problems</li> <li>Join our Discord community for real-time help (not yet setup)</li> <li>Open a new issue with detailed information about your problem</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have FuryMesh installed, proceed to the Quick Start guide to learn how to use it.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will help you get started with FuryMesh quickly. We'll cover the basics of setting up a node, connecting to the network, and transferring files.</p>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quick-start/#starting-a-node","title":"Starting a Node","text":"<p>First, let's start a FuryMesh node:</p> <pre><code># Start a node with default settings\nfurymesh start\n\n# Or with custom settings\nfurymesh start --port 8080 --data-dir ./data\n</code></pre> <p>This will start a FuryMesh node that listens for incoming connections and can participate in the network.</p>"},{"location":"getting-started/quick-start/#connecting-to-the-network","title":"Connecting to the Network","text":"<p>To connect to the FuryMesh network, you need to bootstrap your node with known peers:</p> <pre><code># Start a node with bootstrap peers\nfurymesh start --bootstrap peer1.example.com:8080,peer2.example.com:8080\n</code></pre> <p>Alternatively, you can specify bootstrap peers in your configuration file:</p> <pre><code># config.yaml\ndht:\n  bootstrap_peers:\n    - \"peer1.example.com:8080\"\n    - \"peer2.example.com:8080\"\n</code></pre> <p>And then start the node with this configuration:</p> <pre><code>furymesh start --config config.yaml\n</code></pre>"},{"location":"getting-started/quick-start/#sharing-a-file","title":"Sharing a File","text":"<p>To share a file with the network:</p> <pre><code># Share a file\nfurymesh share --file /path/to/your/file.txt\n</code></pre> <p>This will chunk the file, generate a unique file ID, and make it available for other peers to download. The command will output the file ID, which you can share with others.</p> <pre><code>File shared successfully:\n  File ID: 3f7b8a1c2d9e4f5a6b7c8d9e0f1a2b3c\n  File Name: file.txt\n  File Size: 1.2 MB\n  Chunks: 5\n</code></pre>"},{"location":"getting-started/quick-start/#listing-shared-files","title":"Listing Shared Files","text":"<p>To see a list of files you're sharing:</p> <pre><code>furymesh list-files\n</code></pre> <p>This will show all files that your node is currently sharing:</p> <pre><code>+----------------------------------+-------------+----------+-------+\n| File ID                          | Name        | Size     | Chunks |\n+----------------------------------+-------------+----------+-------+\n| 3f7b8a1c2d9e4f5a6b7c8d9e0f1a2b3c | file.txt    | 1.2 MB   | 5     |\n| 7a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d | image.jpg   | 2.5 MB   | 10    |\n+----------------------------------+-------------+----------+-------+\n</code></pre>"},{"location":"getting-started/quick-start/#downloading-a-file","title":"Downloading a File","text":"<p>To download a file from a peer:</p> <pre><code># Download a file\nfurymesh download --peer-id peer-id-here --file-id file-id-here --output /path/to/output\n</code></pre> <p>You can monitor the progress of the download:</p> <pre><code>Downloading file 3f7b8a1c2d9e4f5a6b7c8d9e0f1a2b3c from peer abc123...\nProgress: [====================] 100% Complete\nFile saved to /path/to/output/file.txt\n</code></pre>"},{"location":"getting-started/quick-start/#multi-peer-download","title":"Multi-Peer Download","text":"<p>To download a file from multiple peers simultaneously:</p> <pre><code># Download a file from multiple peers\nfurymesh download --file-id file-id-here --multi-peer --output /path/to/output\n</code></pre> <p>This will automatically discover peers that have the file and download different chunks from different peers.</p>"},{"location":"getting-started/quick-start/#resuming-a-transfer","title":"Resuming a Transfer","text":"<p>If a transfer is interrupted, you can resume it:</p> <pre><code># Resume a transfer\nfurymesh resume --file-id file-id-here\n</code></pre> <p>FuryMesh will automatically continue from where it left off, downloading only the missing chunks.</p>"},{"location":"getting-started/quick-start/#using-the-configuration-file","title":"Using the Configuration File","text":"<p>FuryMesh can be configured using a YAML configuration file:</p> <pre><code># config.yaml\nnode:\n  id: \"my-node\"\n  port: 8080\n  data_dir: \"./data\"\n\ndht:\n  bootstrap_peers:\n    - \"peer1.example.com:8080\"\n    - \"peer2.example.com:8080\"\n\nwebrtc:\n  stun_servers:\n    - \"stun:stun.l.google.com:19302\"\n  turn_servers:\n    - url: \"turn:turn.example.com:3478\"\n      username: \"username\"\n      password: \"password\"\n\ntransfer:\n  concurrent_transfers: 5\n  chunk_size: 1048576  # 1MB\n  chunk_selection_strategy: \"rarest_first\"  # or \"round_robin\"\n</code></pre> <p>Start FuryMesh with this configuration:</p> <pre><code>furymesh start --config config.yaml\n</code></pre>"},{"location":"getting-started/quick-start/#advanced-commands","title":"Advanced Commands","text":""},{"location":"getting-started/quick-start/#listing-peers","title":"Listing Peers","text":"<p>To see a list of connected peers:</p> <pre><code>furymesh list-peers\n</code></pre>"},{"location":"getting-started/quick-start/#checking-transfer-status","title":"Checking Transfer Status","text":"<p>To check the status of ongoing transfers:</p> <pre><code>furymesh status --file-id file-id-here\n</code></pre>"},{"location":"getting-started/quick-start/#getting-storage-statistics","title":"Getting Storage Statistics","text":"<p>To see storage usage statistics:</p> <pre><code>furymesh stats\n</code></pre>"},{"location":"getting-started/quick-start/#deleting-a-file","title":"Deleting a File","text":"<p>To delete a file from your node:</p> <pre><code>furymesh delete --file-id file-id-here\n</code></pre>"},{"location":"getting-started/quick-start/#running-as-a-service","title":"Running as a Service","text":""},{"location":"getting-started/quick-start/#linux-systemd","title":"Linux (systemd)","text":"<p>Create a systemd service file:</p> <pre><code>sudo nano /etc/systemd/system/furymesh.service\n</code></pre> <p>Add the following content:</p> <pre><code>[Unit]\nDescription=FuryMesh P2P File Sharing\nAfter=network.target\n\n[Service]\nExecStart=/usr/local/bin/furymesh start --config /etc/furymesh/config.yaml\nRestart=on-failure\nUser=furymesh\nGroup=furymesh\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Enable and start the service:</p> <pre><code>sudo systemctl enable furymesh\nsudo systemctl start furymesh\n</code></pre>"},{"location":"getting-started/quick-start/#macos-launchd","title":"macOS (launchd)","text":"<p>Create a launchd plist file:</p> <pre><code>nano ~/Library/LaunchAgents/com.tfmv.furymesh.plist\n</code></pre> <p>Add the following content:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;Label&lt;/key&gt;\n    &lt;string&gt;com.tfmv.furymesh&lt;/string&gt;\n    &lt;key&gt;ProgramArguments&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;/usr/local/bin/furymesh&lt;/string&gt;\n        &lt;string&gt;start&lt;/string&gt;\n        &lt;string&gt;--config&lt;/string&gt;\n        &lt;string&gt;/Users/username/furymesh/config.yaml&lt;/string&gt;\n    &lt;/array&gt;\n    &lt;key&gt;RunAtLoad&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;key&gt;KeepAlive&lt;/key&gt;\n    &lt;true/&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;\n</code></pre> <p>Load the service:</p> <pre><code>launchctl load ~/Library/LaunchAgents/com.tfmv.furymesh.plist\n</code></pre>"},{"location":"getting-started/quick-start/#windows-windows-service","title":"Windows (Windows Service)","text":"<p>Install FuryMesh as a Windows service using NSSM:</p> <pre><code>nssm install FuryMesh C:\\path\\to\\furymesh.exe start --config C:\\path\\to\\config.yaml\nnssm start FuryMesh\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of FuryMesh, you can:</p> <ul> <li>Learn about Configuration options</li> <li>Explore Multi-Peer Transfers</li> <li>Understand Resume Support</li> <li>Check out the Command Line Reference</li> </ul>"},{"location":"usage/command-line/","title":"Command Line Reference","text":"<p>FuryMesh provides a comprehensive command-line interface (CLI) for interacting with the application. This reference documents all available commands and their options.</p>"},{"location":"usage/command-line/#global-options","title":"Global Options","text":"<p>These options can be used with any command:</p> <pre><code>--config &lt;path&gt;       Path to the configuration file (default: config.yaml)\n--verbose, -v         Enable verbose output\n--help, -h            Show help for a command\n--version             Show version information\n</code></pre>"},{"location":"usage/command-line/#basic-commands","title":"Basic Commands","text":""},{"location":"usage/command-line/#start","title":"Start","text":"<p>Start a FuryMesh node:</p> <pre><code>furymesh start [options]\n</code></pre> <p>Options:</p> <pre><code>--port &lt;port&gt;                 Port to listen on (default: 8080)\n--data-dir &lt;path&gt;             Directory to store data (default: ./data)\n--bootstrap &lt;peers&gt;           Comma-separated list of bootstrap peers\n--debug                       Enable debug mode\n--log-level &lt;level&gt;           Set log level (debug, info, warn, error)\n--stun &lt;servers&gt;              Comma-separated list of STUN servers\n--turn &lt;servers&gt;              Comma-separated list of TURN servers\n--turn-username &lt;username&gt;    Username for TURN authentication\n--turn-password &lt;password&gt;    Password for TURN authentication\n</code></pre> <p>Example:</p> <pre><code>furymesh start --port 8080 --bootstrap peer1.example.com:8080\n</code></pre>"},{"location":"usage/command-line/#share","title":"Share","text":"<p>Share a file with the network:</p> <pre><code>furymesh share [options]\n</code></pre> <p>Options:</p> <pre><code>--file &lt;path&gt;         Path to the file to share\n--encrypt             Encrypt the file before sharing\n--chunk-size &lt;size&gt;   Size of each chunk in bytes (default: 1MB)\n</code></pre> <p>Example:</p> <pre><code>furymesh share --file /path/to/file.txt --encrypt\n</code></pre>"},{"location":"usage/command-line/#download","title":"Download","text":"<p>Download a file from a peer:</p> <pre><code>furymesh download [options]\n</code></pre> <p>Options:</p> <pre><code>--file-id &lt;id&gt;        ID of the file to download\n--peer-id &lt;id&gt;        ID of the peer to download from\n--output &lt;path&gt;       Path to save the downloaded file\n--multi-peer          Download from multiple peers\n--max-peers &lt;count&gt;   Maximum number of peers to use (default: 5)\n--strategy &lt;strategy&gt; Chunk selection strategy (rarest_first or round_robin)\n--peers &lt;peers&gt;       Comma-separated list of specific peers to use\n</code></pre> <p>Example:</p> <pre><code>furymesh download --file-id abc123 --output /path/to/output --multi-peer\n</code></pre>"},{"location":"usage/command-line/#resume","title":"Resume","text":"<p>Resume an interrupted download:</p> <pre><code>furymesh resume [options]\n</code></pre> <p>Options:</p> <pre><code>--file-id &lt;id&gt;        ID of the file to resume\n--output &lt;path&gt;       Path to save the downloaded file\n--peer-id &lt;id&gt;        ID of the peer to download from\n--multi-peer          Download from multiple peers\n--max-peers &lt;count&gt;   Maximum number of peers to use (default: 5)\n</code></pre> <p>Example:</p> <pre><code>furymesh resume --file-id abc123 --multi-peer\n</code></pre>"},{"location":"usage/command-line/#information-commands","title":"Information Commands","text":""},{"location":"usage/command-line/#list-files","title":"List Files","text":"<p>List files being shared:</p> <pre><code>furymesh list-files [options]\n</code></pre> <p>Options:</p> <pre><code>--format &lt;format&gt;     Output format (table, json, csv)\n--sort &lt;field&gt;        Sort by field (name, size, date)\n</code></pre> <p>Example:</p> <pre><code>furymesh list-files --format json\n</code></pre>"},{"location":"usage/command-line/#list-peers","title":"List Peers","text":"<p>List connected peers:</p> <pre><code>furymesh list-peers [options]\n</code></pre> <p>Options:</p> <pre><code>--format &lt;format&gt;     Output format (table, json, csv)\n--sort &lt;field&gt;        Sort by field (id, files, last_seen)\n</code></pre> <p>Example:</p> <pre><code>furymesh list-peers --sort last_seen\n</code></pre>"},{"location":"usage/command-line/#status","title":"Status","text":"<p>Show the status of transfers:</p> <pre><code>furymesh status [options]\n</code></pre> <p>Options:</p> <pre><code>--file-id &lt;id&gt;        Show status for a specific file\n--verbose             Show detailed information\n--format &lt;format&gt;     Output format (table, json, csv)\n</code></pre> <p>Example:</p> <pre><code>furymesh status --file-id abc123 --verbose\n</code></pre>"},{"location":"usage/command-line/#stats","title":"Stats","text":"<p>Show storage and network statistics:</p> <pre><code>furymesh stats [options]\n</code></pre> <p>Options:</p> <pre><code>--format &lt;format&gt;     Output format (table, json, csv)\n</code></pre> <p>Example:</p> <pre><code>furymesh stats --format json\n</code></pre>"},{"location":"usage/command-line/#management-commands","title":"Management Commands","text":""},{"location":"usage/command-line/#delete","title":"Delete","text":"<p>Delete a file:</p> <pre><code>furymesh delete [options]\n</code></pre> <p>Options:</p> <pre><code>--file-id &lt;id&gt;        ID of the file to delete\n--force               Force deletion without confirmation\n</code></pre> <p>Example:</p> <pre><code>furymesh delete --file-id abc123\n</code></pre>"},{"location":"usage/command-line/#clean-resume","title":"Clean Resume","text":"<p>Clean up resume data:</p> <pre><code>furymesh clean-resume [options]\n</code></pre> <p>Options:</p> <pre><code>--file-id &lt;id&gt;        ID of the file to clean\n--all                 Clean all resume data\n--force               Force cleanup without confirmation\n</code></pre> <p>Example:</p> <pre><code>furymesh clean-resume --all\n</code></pre>"},{"location":"usage/command-line/#list-resume","title":"List Resume","text":"<p>List available resume data:</p> <pre><code>furymesh list-resume [options]\n</code></pre> <p>Options:</p> <pre><code>--format &lt;format&gt;     Output format (table, json, csv)\n</code></pre> <p>Example:</p> <pre><code>furymesh list-resume\n</code></pre>"},{"location":"usage/command-line/#resume-info","title":"Resume Info","text":"<p>Show detailed information about resume data:</p> <pre><code>furymesh resume-info [options]\n</code></pre> <p>Options:</p> <pre><code>--file-id &lt;id&gt;        ID of the file to show info for\n--format &lt;format&gt;     Output format (table, json, csv)\n</code></pre> <p>Example:</p> <pre><code>furymesh resume-info --file-id abc123\n</code></pre>"},{"location":"usage/command-line/#advanced-commands","title":"Advanced Commands","text":""},{"location":"usage/command-line/#generate-key","title":"Generate Key","text":"<p>Generate a new encryption key:</p> <pre><code>furymesh generate-key [options]\n</code></pre> <p>Options:</p> <pre><code>--size &lt;bits&gt;         Key size in bits (default: 2048)\n--output &lt;path&gt;       Path to save the key\n</code></pre> <p>Example:</p> <pre><code>furymesh generate-key --size 4096 --output /path/to/key\n</code></pre>"},{"location":"usage/command-line/#export","title":"Export","text":"<p>Export files or configuration:</p> <pre><code>furymesh export [options]\n</code></pre> <p>Options:</p> <pre><code>--files               Export list of shared files\n--config              Export current configuration\n--output &lt;path&gt;       Path to save the export\n--format &lt;format&gt;     Output format (json, yaml)\n</code></pre> <p>Example:</p> <pre><code>furymesh export --files --output /path/to/export.json\n</code></pre>"},{"location":"usage/command-line/#import","title":"Import","text":"<p>Import files or configuration:</p> <pre><code>furymesh import [options]\n</code></pre> <p>Options:</p> <pre><code>--files &lt;path&gt;        Import list of shared files\n--config &lt;path&gt;       Import configuration\n</code></pre> <p>Example:</p> <pre><code>furymesh import --config /path/to/config.yaml\n</code></pre>"},{"location":"usage/command-line/#examples","title":"Examples","text":""},{"location":"usage/command-line/#basic-node-setup","title":"Basic Node Setup","text":"<pre><code># Start a node with default settings\nfurymesh start\n\n# Start a node with custom settings\nfurymesh start --port 8080 --data-dir ./data --bootstrap peer1.example.com:8080\n</code></pre>"},{"location":"usage/command-line/#file-sharing","title":"File Sharing","text":"<pre><code># Share a file\nfurymesh share --file /path/to/file.txt\n\n# Share an encrypted file\nfurymesh share --file /path/to/file.txt --encrypt\n</code></pre>"},{"location":"usage/command-line/#file-downloading","title":"File Downloading","text":"<pre><code># Download a file from a specific peer\nfurymesh download --file-id abc123 --peer-id xyz789 --output /path/to/output\n\n# Download a file from multiple peers\nfurymesh download --file-id abc123 --multi-peer --output /path/to/output\n\n# Download a file with a specific chunk selection strategy\nfurymesh download --file-id abc123 --multi-peer --strategy rarest_first --output /path/to/output\n</code></pre>"},{"location":"usage/command-line/#managing-transfers","title":"Managing Transfers","text":"<pre><code># Resume an interrupted transfer\nfurymesh resume --file-id abc123\n\n# Check the status of a transfer\nfurymesh status --file-id abc123 --verbose\n\n# Delete a file\nfurymesh delete --file-id abc123\n</code></pre>"},{"location":"usage/command-line/#information-gathering","title":"Information Gathering","text":"<pre><code># List shared files\nfurymesh list-files\n\n# List connected peers\nfurymesh list-peers\n\n# Show storage statistics\nfurymesh stats\n</code></pre>"},{"location":"usage/troubleshooting_webrtc/","title":"Troubleshooting WebRTC Connections","text":"<p>This guide helps you diagnose and resolve common issues with WebRTC connections in FuryMesh.</p>"},{"location":"usage/troubleshooting_webrtc/#common-connection-issues","title":"Common Connection Issues","text":""},{"location":"usage/troubleshooting_webrtc/#unable-to-establish-connection","title":"Unable to Establish Connection","text":"<p>If peers cannot establish a WebRTC connection:</p> <ol> <li>Check Network Configuration:</li> <li>Ensure both peers have internet connectivity</li> <li>Verify that required ports are not blocked by firewalls</li> <li> <p>WebRTC typically uses UDP ports 1025-65535</p> </li> <li> <p>STUN/TURN Server Issues:</p> </li> <li>Verify STUN servers are accessible</li> <li>Consider adding TURN servers for difficult NAT scenarios</li> <li> <p>Update your configuration:</p> <pre><code>webrtc:\n  stun_servers:\n    - \"stun:stun.l.google.com:19302\"\n    - \"stun:stun1.l.google.com:19302\"\n  turn_servers:\n    - \"turn:your-turn-server.com:3478\"\n  username: \"your-username\"  # For TURN\n  credential: \"your-password\"  # For TURN\n</code></pre> </li> <li> <p>NAT Traversal Problems:</p> </li> <li>Some NAT configurations are challenging for WebRTC</li> <li>If behind symmetric NAT, TURN servers are usually required</li> <li>Check logs for ICE connectivity failures</li> </ol>"},{"location":"usage/troubleshooting_webrtc/#connection-drops-frequently","title":"Connection Drops Frequently","text":"<p>If connections are established but drop frequently:</p> <ol> <li>Network Stability:</li> <li>Check for network congestion or instability</li> <li> <p>Ensure sufficient bandwidth for transfers</p> </li> <li> <p>Adjust Timeouts:</p> </li> <li> <p>Increase ICE timeout for challenging networks:</p> <pre><code>webrtc:\n  ice_timeout: 60  # Increase from default 30 seconds\n</code></pre> </li> <li> <p>Check Resource Usage:</p> </li> <li>High CPU or memory usage can affect WebRTC stability</li> <li>Reduce concurrent transfers if system is overloaded</li> </ol>"},{"location":"usage/troubleshooting_webrtc/#transfer-issues","title":"Transfer Issues","text":""},{"location":"usage/troubleshooting_webrtc/#slow-transfer-speeds","title":"Slow Transfer Speeds","text":"<p>If file transfers are slower than expected:</p> <ol> <li>Adjust Chunk Size:</li> <li>Larger chunks may improve throughput on stable connections</li> <li>Smaller chunks work better on unstable connections</li> </ol> <pre><code>transfer:\n  chunk_size: 2097152  # Increase to 2MB for faster networks\n</code></pre> <ol> <li>Increase Concurrent Chunks:</li> <li>More concurrent transfers can improve throughput</li> </ol> <pre><code>transfer:\n  max_concurrent_chunks: 10  # Increase from default 5\n</code></pre> <ol> <li>Network Limitations:</li> <li>Check if your network has bandwidth limitations</li> <li>WebRTC performance depends on the slowest peer's connection</li> </ol>"},{"location":"usage/troubleshooting_webrtc/#failed-transfers","title":"Failed Transfers","text":"<p>If transfers fail to complete:</p> <ol> <li>Increase Retry Attempts:</li> </ol> <pre><code>transfer:\n  max_retries: 5  # Increase from default 3\n</code></pre> <ol> <li>Adjust Retry Interval:</li> </ol> <pre><code>transfer:\n  retry_interval: 10s  # Increase from default 5s\n</code></pre> <ol> <li>Increase Idle Timeout:</li> </ol> <pre><code>transfer:\n  idle_timeout: 60s  # Increase from default 30s\n</code></pre> <ol> <li>Check Logs for Specific Errors:</li> <li>Look for timeout or connection errors</li> <li>Check for chunk transfer failures</li> </ol>"},{"location":"usage/troubleshooting_webrtc/#debugging-tools","title":"Debugging Tools","text":""},{"location":"usage/troubleshooting_webrtc/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<p>Increase log verbosity to get more detailed information:</p> <pre><code>logging:\n  level: \"debug\"  # Set to debug for more detailed logs\n  webrtc_level: \"debug\"\n</code></pre>"},{"location":"usage/troubleshooting_webrtc/#check-connection-states","title":"Check Connection States","text":"<p>Monitor connection states in the logs:</p> <ul> <li>New: Connection created but not active</li> <li>Connecting: ICE negotiation in progress</li> <li>Connected: Connection established</li> <li>Disconnected: Temporarily disconnected</li> <li>Failed: Connection failed</li> <li>Closed: Connection closed</li> </ul>"},{"location":"usage/troubleshooting_webrtc/#monitor-transfer-statistics","title":"Monitor Transfer Statistics","text":"<p>Use the transfer statistics to diagnose issues:</p> <pre><code>stats, err := fileManager.GetTransferStats(fileID)\nif err == nil {\n    fmt.Printf(\"Transfer progress: %d/%d chunks\\n\", \n        stats.CompletedChunks, stats.TotalChunks)\n    fmt.Printf(\"Transfer rate: %.2f KB/s\\n\", \n        stats.TransferRate / 1024)\n}\n</code></pre>"},{"location":"usage/troubleshooting_webrtc/#advanced-troubleshooting","title":"Advanced Troubleshooting","text":""},{"location":"usage/troubleshooting_webrtc/#webrtc-signaling-issues","title":"WebRTC Signaling Issues","text":"<p>If signaling fails:</p> <ol> <li>Check DHT connectivity</li> <li>Verify that signaling messages are being exchanged</li> <li>Look for errors in the signaling process</li> </ol>"},{"location":"usage/troubleshooting_webrtc/#ice-candidate-exchange-problems","title":"ICE Candidate Exchange Problems","text":"<p>If ICE candidates are not being exchanged properly:</p> <ol> <li>Check for firewall or NAT issues</li> <li>Verify STUN server connectivity</li> <li>Consider using TURN servers as a fallback</li> </ol>"},{"location":"usage/troubleshooting_webrtc/#data-channel-problems","title":"Data Channel Problems","text":"<p>If data channels fail to open or send data:</p> <ol> <li>Check for negotiation errors</li> <li>Verify that both peers support the data channel configuration</li> <li>Look for buffer overflow issues with large transfers</li> </ol>"},{"location":"usage/troubleshooting_webrtc/#getting-help","title":"Getting Help","text":"<p>If you continue to experience issues:</p> <ol> <li>Gather detailed logs with debug level enabled</li> <li>Check the GitHub issues for similar problems</li> <li>Provide detailed information when reporting issues:</li> <li>Network configuration</li> <li>FuryMesh version</li> <li>Error messages and logs</li> <li>Steps to reproduce the issue</li> </ol>"}]}